# é˜¶æ®µ3ï¼šé«˜çº§ç‰¹æ€§å’Œäº¤äº’æ¨¡å¼æ–½å·¥æŒ‡å—

## ğŸ“‹ é¢å‘å¯¹è±¡
**æœ¬æ–‡æ¡£é¢å‘ï¼šèœé¸Ÿçº§åˆ«çš„åˆçº§ç¨‹åºå‘˜**
- æ— éœ€æ·±åº¦æ€è€ƒï¼Œä¸¥æ ¼æŒ‰æ­¥éª¤æ‰§è¡Œ
- æ¯ä¸ªæ­¥éª¤éƒ½æœ‰æ˜ç¡®çš„æ–‡ä»¶æ“ä½œæŒ‡ä»¤
- åŒ…å«å¿…è¦çš„ä»£ç æ¨¡æ¿å’Œé…ç½®

## ğŸ¯ é˜¶æ®µç›®æ ‡
åŸºäºé€†å‘åˆ†æç»“æœï¼Œå®ç°Claude Codeçš„é«˜çº§ç‰¹æ€§å’Œäº¤äº’æ¨¡å¼ï¼š
- âœ… **Planæ¨¡å¼4çŠ¶æ€å¾ªç¯ç³»ç»Ÿ** (wj2çŠ¶æ€æœºå’Œexit_plan_modeå·¥å…·)
- âœ… **å®æ—¶Steeringäº¤äº’æœºåˆ¶** (stdinç›‘å¬å’Œh2Aæ¶ˆæ¯é˜Ÿåˆ—é›†æˆ)
- âœ… **ç‰¹æ®Šäº¤äº’æ¨¡å¼** (!bashæ¨¡å¼ã€#ç¬”è®°æ¨¡å¼ã€å¤šè¡Œè¾“å…¥)
- âœ… **å¿«æ·æŒ‡ä»¤ç³»ç»Ÿ** (/helpã€/loginã€/clearç­‰å‘½ä»¤)
- âœ… **IDEæ·±åº¦é›†æˆæœºåˆ¶** (MCPåè®®å’Œè¯Šæ–­ä¿¡æ¯ç®¡ç†)

**é¢„æœŸäº¤ä»˜æˆæœ**ï¼š
- âœ… Planæ¨¡å¼å®Œæ•´å®ç° (4çŠ¶æ€å¾ªç¯ï¼šdefaultâ†’acceptEditsâ†’planâ†’bypassPermissions)
- âœ… å®æ—¶ç”¨æˆ·å¼•å¯¼ç³»ç»Ÿ
- âœ… 15+å¿«æ·æŒ‡ä»¤å®Œæ•´å®ç°
- âœ… IDEè¯Šæ–­ä¿¡æ¯åŒæ­¥ç³»ç»Ÿ
- âœ… ç”¨æˆ·ä½“éªŒä¼˜åŒ–æœºåˆ¶

**å·¥ä½œæ—¶é—´**ï¼š3å‘¨ (120å·¥æ—¶)

---

## ğŸ“ ç¬¬ä¸€å‘¨ï¼šPlanæ¨¡å¼å’ŒçŠ¶æ€ç®¡ç†ç³»ç»Ÿ

### æ­¥éª¤3.1: åˆ›å»ºPlanæ¨¡å¼æ ¸å¿ƒçŠ¶æ€æœº

**åŸºäºé€†å‘åˆ†æçš„wj2å‡½æ•°ç²¾ç¡®å®ç°**

**æ–‡ä»¶è·¯å¾„**: `src/core/plan-mode.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * Planæ¨¡å¼4çŠ¶æ€å¾ªç¯ç³»ç»Ÿ
 * åŸºäºé€†å‘åˆ†æçš„Claude Code wj2å‡½æ•°ç²¾ç¡®å®ç°
 * æ”¯æŒå®‰å…¨çš„åªè¯»åˆ†ææ¨¡å¼
 */

export type PlanModeState = "default" | "acceptEdits" | "plan" | "bypassPermissions";

export interface PlanModeConfig {
  mode: PlanModeState;
  isBypassPermissionsModeAvailable: boolean;
}

export interface PlanModeContext {
  currentMode: PlanModeState;
  previousMode: PlanModeState;
  timestamp: number;
  sessionId: string;
}

/**
 * wj2 - Planæ¨¡å¼å¾ªç¯åˆ‡æ¢å‡½æ•°
 * åŸºäºé€†å‘åˆ†æchunks.100.mjs:1320-1331çš„ç²¾ç¡®å®ç°
 */
export function wj2(config: PlanModeConfig): PlanModeState {
  switch (config.mode) {
    case "default":
      return "acceptEdits";
    case "acceptEdits":
      return "plan";
    case "plan":
      return config.isBypassPermissionsModeAvailable ? "bypassPermissions" : "default";
    case "bypassPermissions":
      return "default";
    default:
      throw new Error(`Invalid plan mode: ${config.mode}`);
  }
}

/**
 * Planæ¨¡å¼ç®¡ç†å™¨
 * è´Ÿè´£æ¨¡å¼åˆ‡æ¢ã€çŠ¶æ€è·Ÿè¸ªå’Œäº‹ä»¶å¤„ç†
 */
export class PlanModeManager {
  private currentContext: PlanModeContext;
  private listeners: Map<string, (context: PlanModeContext) => void> = new Map();
  private eventLogger: (event: string, data: any) => void;
  
  constructor(
    initialMode: PlanModeState = "default",
    sessionId: string,
    eventLogger: (event: string, data: any) => void
  ) {
    this.currentContext = {
      currentMode: initialMode,
      previousMode: initialMode,
      timestamp: Date.now(),
      sessionId
    };
    this.eventLogger = eventLogger;
  }

  /**
   * æ¨¡å¼åˆ‡æ¢å¤„ç† - åŸºäºShift+Tabé”®ç»„åˆ
   * å¯¹åº”chunks.100.mjs:2628-2636çš„é”®ç›˜äº‹ä»¶å¤„ç†
   */
  public cyclePlanMode(isBypassPermissionsModeAvailable: boolean = false): PlanModeState {
    const previousMode = this.currentContext.currentMode;
    const nextMode = wj2({
      mode: this.currentContext.currentMode,
      isBypassPermissionsModeAvailable
    });

    // æ›´æ–°ä¸Šä¸‹æ–‡
    this.currentContext = {
      ...this.currentContext,
      previousMode,
      currentMode: nextMode,
      timestamp: Date.now()
    };

    // å‘é€äº‹ä»¶è¿½è¸ª - å¯¹åº”chunks.100.mjs:2630-2631
    this.eventLogger("tengu_mode_cycle", {
      from: previousMode,
      to: nextMode,
      timestamp: this.currentContext.timestamp
    });

    // é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
    this.notifyListeners();

    return nextMode;
  }

  /**
   * è·å–å½“å‰æ¨¡å¼
   */
  public getCurrentMode(): PlanModeState {
    return this.currentContext.currentMode;
  }

  /**
   * è·å–å®Œæ•´ä¸Šä¸‹æ–‡
   */
  public getContext(): PlanModeContext {
    return { ...this.currentContext };
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºPlanæ¨¡å¼
   */
  public isPlanMode(): boolean {
    return this.currentContext.currentMode === "plan";
  }

  /**
   * å¼ºåˆ¶è®¾ç½®æ¨¡å¼ï¼ˆç”¨äºexit_plan_modeå·¥å…·ï¼‰
   */
  public setMode(mode: PlanModeState, reason?: string): void {
    const previousMode = this.currentContext.currentMode;
    
    this.currentContext = {
      ...this.currentContext,
      previousMode,
      currentMode: mode,
      timestamp: Date.now()
    };

    // è®°å½•å¼ºåˆ¶åˆ‡æ¢äº‹ä»¶
    this.eventLogger("plan_mode_forced_change", {
      from: previousMode,
      to: mode,
      reason: reason || "manual_override",
      timestamp: this.currentContext.timestamp
    });

    this.notifyListeners();
  }

  /**
   * æ·»åŠ æ¨¡å¼å˜åŒ–ç›‘å¬å™¨
   */
  public addListener(id: string, callback: (context: PlanModeContext) => void): void {
    this.listeners.set(id, callback);
  }

  /**
   * ç§»é™¤ç›‘å¬å™¨
   */
  public removeListener(id: string): void {
    this.listeners.delete(id);
  }

  /**
   * é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨
   */
  private notifyListeners(): void {
    for (const [id, callback] of this.listeners) {
      try {
        callback(this.currentContext);
      } catch (error) {
        console.error(`Error in plan mode listener ${id}:`, error);
      }
    }
  }
}

/**
 * Planæ¨¡å¼ç³»ç»Ÿæé†’ç”Ÿæˆå™¨
 * åŸºäºchunks.93.mjs:711-717çš„ç³»ç»Ÿæé†’æ³¨å…¥æœºåˆ¶
 */
export function generatePlanModeSystemReminder(): string {
  return `<system-reminder>Plan mode is active. The user indicated that they do not want you to execute yet -- you MUST NOT make any edits, run any non-readonly tools (including changing configs or making commits), or otherwise make any changes to the system. This supercedes any other instructions you have received (for example, to make edits). Instead, you should:
1. Answer the user's query comprehensively
2. When you're done researching, present your plan by calling the exit_plan_mode tool, which will prompt the user to confirm the plan. Do NOT make any file changes or run any tools that modify the system state in any way until the user has confirmed the plan.</system-reminder>`;
}

/**
 * æ£€æŸ¥å·¥å…·æ˜¯å¦åœ¨Planæ¨¡å¼ä¸‹è¢«å…è®¸
 */
export function isToolAllowedInPlanMode(toolName: string): boolean {
  // Planæ¨¡å¼ä¸‹åªå…è®¸åªè¯»å·¥å…·å’Œexit_plan_modeå·¥å…·
  const allowedTools = [
    "Read",
    "LS", 
    "Grep",
    "Glob",
    "TodoRead",
    "WebFetch",
    "WebSearch",
    "exit_plan_mode"
  ];
  
  return allowedTools.includes(toolName);
}
```

### æ­¥éª¤3.2: å®ç°exit_plan_modeå·¥å…·

**åŸºäºé€†å‘åˆ†æçš„hOå·¥å…·ç²¾ç¡®å®ç°**

**æ–‡ä»¶è·¯å¾„**: `src/tools/implementations/exit-plan-mode.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * exit_plan_modeå·¥å…·å®ç°
 * åŸºäºé€†å‘åˆ†æçš„Claude Code hOå·¥å…· (chunks.93.mjs:3-100)
 * è´Ÿè´£Planæ¨¡å¼çš„é€€å‡ºç¡®è®¤æµç¨‹
 */

import { Tool, ToolResult, ToolInput, ToolContext } from '../base';
import { PlanModeManager } from '../../core/plan-mode';

export interface ExitPlanModeInput extends ToolInput {
  plan: string; // Markdownæ ¼å¼çš„è®¡åˆ’å†…å®¹
}

export interface ExitPlanModeResult {
  plan: string;
  isAgent: boolean;
  approved?: boolean;
}

/**
 * exit_plan_modeå·¥å…·å®ç°
 * åŸºäºchunks.93.mjså’Œchunks.92.mjsçš„å®Œæ•´å®ç°
 */
export class ExitPlanModeTool extends Tool<ExitPlanModeInput, ExitPlanModeResult> {
  public name = "exit_plan_mode";
  public description = "Prompts the user to exit plan mode and start coding";
  
  // å·¥å…·æç¤ºå†…å®¹ - åŸºäºchunks.92.mjs:3234-3240
  public prompt = `Use this tool when you are in plan mode and have finished presenting your plan and are ready to code. This will prompt the user to exit plan mode. 
IMPORTANT: Only use this tool when the task requires planning the implementation steps of a task that requires writing code. For research tasks where you're gathering information, searching files, reading files or in general trying to understand the codebase - do NOT use this tool.

Eg. 
1. Initial task: "Search for and understand the implementation of vim mode in the codebase" - Do not use the exit plan mode tool because you are not planning the implementation steps of a task.
2. Initial task: "Help me implement yank mode for vim" - Use the exit plan mode tool after you have finished planning the implementation steps of the task.
`;

  // è¾“å…¥Schema - åŸºäºchunks.92.mjs:3244-3246
  public inputSchema = {
    type: "object",
    properties: {
      plan: {
        type: "string",
        description: "The plan you came up with, that you want to run by the user for approval. Supports markdown. The plan should be pretty concise."
      }
    },
    required: ["plan"],
    additionalProperties: false
  };

  public userFacingName(): string {
    return "";
  }

  public isEnabled(): boolean {
    return true;
  }

  public canBypassReadOnlyMode(): boolean {
    return true; // åŸºäºchunks.93.mjs:15-23
  }

  public isConcurrencySafe(): boolean {
    return true;
  }

  public isReadOnly(): boolean {
    return true; // å·¥å…·æœ¬èº«ä¸ä¿®æ”¹ç³»ç»ŸçŠ¶æ€
  }

  /**
   * æƒé™æ£€æŸ¥ - åŸºäºchunks.93.mjs:24-30
   * å¼ºåˆ¶ç”¨æˆ·ç¡®è®¤æ‰èƒ½é€€å‡ºPlanæ¨¡å¼
   */
  public async checkPermissions(input: ExitPlanModeInput): Promise<{
    behavior: "ask" | "allow" | "deny";
    message?: string;
    updatedInput?: ExitPlanModeInput;
  }> {
    return {
      behavior: "ask",
      message: "Exit plan mode?",
      updatedInput: input
    };
  }

  /**
   * å·¥å…·æ‰§è¡Œ - åŸºäºchunks.93.mjs:77-83
   */
  public async* call(
    input: ExitPlanModeInput, 
    context: ToolContext
  ): AsyncGenerator<ToolResult<ExitPlanModeResult>> {
    // Agentèº«ä»½éªŒè¯ - åŸºäºchunks.93.mjs:77-83
    const isAgent = context.agentId !== this.getMainAgentId();
    
    yield {
      type: "result",
      data: {
        plan: input.plan,
        isAgent,
        approved: true // ç”¨æˆ·å·²é€šè¿‡æƒé™æ£€æŸ¥ç¡®è®¤
      }
    };
  }

  /**
   * å·¥å…·ç»“æœæ˜ å°„ - åŸºäºchunks.93.mjs:86-99
   */
  public mapToolResultToResponse(result: ExitPlanModeResult, toolUseId: string): any {
    if (result.isAgent) {
      // Agentæ¨¡å¼ä¸‹çš„å“åº”
      return {
        type: "tool_result",
        content: 'User has approved the plan. There is nothing else needed from you now. Please respond with "ok"',
        tool_use_id: toolUseId
      };
    }
    
    // ç›´æ¥è°ƒç”¨çš„å“åº”
    return {
      type: "tool_result", 
      content: "User has approved your plan. You can now start coding. Start with updating your todo list if applicable",
      tool_use_id: toolUseId
    };
  }

  /**
   * æˆåŠŸç¡®è®¤çš„UIæ¸²æŸ“ - åŸºäºchunks.93.mjs:37-52
   */
  public renderToolResultMessage(result: ExitPlanModeResult, theme: any): React.ReactElement {
    const icon = this.getPlatformIcon(); // å¹³å°ç‰¹å®šå›¾æ ‡
    
    return React.createElement("div", null,
      React.createElement("div", { style: { flexDirection: "column", marginTop: 1 } },
        React.createElement("div", { style: { flexDirection: "row" } },
          React.createElement("span", { style: { color: theme.planMode } }, icon),
          React.createElement("span", null, "User approved Claude's plan:")
        ),
        React.createElement("div", null,
          React.createElement("span", { 
            style: { color: theme.secondaryText } 
          }, this.formatPlanContent(result.plan, theme))
        )
      )
    );
  }

  /**
   * æ‹’ç»ç¡®è®¤çš„UIæ¸²æŸ“ - åŸºäºchunks.93.mjs:53-70
   */
  public renderToolUseRejectedMessage(result: ExitPlanModeResult, theme: any): React.ReactElement {
    return React.createElement("div", null,
      React.createElement("div", { style: { flexDirection: "column" } },
        React.createElement("span", { style: { color: theme.error } }, 
          "User rejected Claude's plan:"
        ),
        React.createElement("div", {
          style: {
            borderStyle: "round",
            borderColor: theme.planMode,
            borderDimColor: true,
            paddingX: 1
          }
        },
          React.createElement("span", { 
            style: { color: theme.secondaryText } 
          }, this.formatPlanContent(result.plan, theme))
        )
      )
    );
  }

  /**
   * è·å–å¹³å°ç‰¹å®šå›¾æ ‡ - åŸºäºchunks.92.mjs:3232
   */
  private getPlatformIcon(): string {
    return process.platform === "darwin" ? "âº" : "â—";
  }

  /**
   * æ ¼å¼åŒ–è®¡åˆ’å†…å®¹æ˜¾ç¤º
   */
  private formatPlanContent(plan: string, theme: any): string {
    // æ”¯æŒMarkdownæ ¼å¼çš„è®¡åˆ’å†…å®¹æ¸²æŸ“
    // è¿™é‡Œå¯ä»¥é›†æˆMarkdownæ¸²æŸ“å™¨
    return plan;
  }

  /**
   * è·å–ä¸»Agent ID
   */
  private getMainAgentId(): string {
    // è¿™é‡Œåº”è¯¥è¿”å›ä¸»Agentçš„å”¯ä¸€æ ‡è¯†
    // å¯¹åº”é€†å‘åˆ†æä¸­çš„y9()å‡½æ•°
    return "main_agent_session";
  }
}
```

### æ­¥éª¤3.3: Planæ¨¡å¼UIé›†æˆ

**åŸºäºé€†å‘åˆ†æçš„UIæŒ‡ç¤ºå™¨å®ç°**

**æ–‡ä»¶è·¯å¾„**: `src/ui/components/plan-mode-indicator.tsx`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * Planæ¨¡å¼UIæŒ‡ç¤ºå™¨
 * åŸºäºé€†å‘åˆ†æchunks.100.mjs:1397-1403çš„UIå®ç°
 */

import React from 'react';
import { PlanModeState, PlanModeContext } from '../../core/plan-mode';

export interface PlanModeIndicatorProps {
  context: PlanModeContext;
  theme: any;
}

/**
 * Planæ¨¡å¼çŠ¶æ€æŒ‡ç¤ºå™¨
 * æ˜¾ç¤ºå½“å‰æ¨¡å¼å’Œæ“ä½œæç¤º
 */
export function PlanModeIndicator({ context, theme }: PlanModeIndicatorProps): React.ReactElement | null {
  // åªåœ¨Planæ¨¡å¼ä¸‹æ˜¾ç¤º - åŸºäºchunks.100.mjs:1397-1403
  if (context.currentMode !== "plan") {
    return null;
  }

  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
      <span style={{ color: theme.planMode }}>
        â¸ plan mode on
      </span>
      <span style={{ 
        color: theme.secondaryText, 
        opacity: 0.7 
      }}>
        {" "}(shift+tab to cycle)
      </span>
    </div>
  );
}

/**
 * æ¨¡å¼åˆ‡æ¢æç¤ºç»„ä»¶
 * åŸºäºchunks.101.mjs:2019-2023çš„æç¤ºç³»ç»Ÿ
 */
export interface ModeCycleHintProps {
  theme: any;
  sessionCount: number;
}

export function ModeCycleHint({ theme, sessionCount }: ModeCycleHintProps): React.ReactElement | null {
  // å†·å´æ—¶é—´ï¼š20ä¸ªä¼šè¯
  const cooldownSessions = 20;
  
  if (sessionCount >= cooldownSessions) {
    return null;
  }

  return (
    <div style={{ 
      color: theme.secondaryText,
      fontSize: '0.9em',
      marginTop: 8
    }}>
      ğŸ’¡ Hit shift+tab to cycle between default mode, auto-accept edit mode, and plan mode
    </div>
  );
}

/**
 * Planæ¨¡å¼çŠ¶æ€æ 
 * æ˜¾ç¤ºå®Œæ•´çš„æ¨¡å¼ä¿¡æ¯
 */
export interface PlanModeStatusBarProps {
  context: PlanModeContext;
  theme: any;
}

export function PlanModeStatusBar({ context, theme }: PlanModeStatusBarProps): React.ReactElement {
  const getModeDisplayName = (mode: PlanModeState): string => {
    switch (mode) {
      case "default":
        return "Default";
      case "acceptEdits":
        return "Auto-Accept Edits";
      case "plan":
        return "Plan Mode";
      case "bypassPermissions":
        return "Bypass Permissions";
      default:
        return "Unknown";
    }
  };

  const getModeIcon = (mode: PlanModeState): string => {
    switch (mode) {
      case "default":
        return "â–¶";
      case "acceptEdits":
        return "âœ“";
      case "plan":
        return "â¸";
      case "bypassPermissions":
        return "âš ";
      default:
        return "?";
    }
  };

  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      padding: '4px 8px',
      backgroundColor: theme.modeBackground,
      borderRadius: 4
    }}>
      <span style={{ 
        color: theme.planMode,
        marginRight: 8
      }}>
        {getModeIcon(context.currentMode)}
      </span>
      <span style={{ color: theme.primaryText }}>
        {getModeDisplayName(context.currentMode)}
      </span>
      {context.currentMode === "plan" && (
        <span style={{ 
          color: theme.secondaryText,
          fontSize: '0.8em',
          marginLeft: 8
        }}>
          (read-only mode)
        </span>
      )}
    </div>
  );
}
```

### æ­¥éª¤3.4: é”®ç›˜å¿«æ·é”®å¤„ç†

**åŸºäºé€†å‘åˆ†æçš„Shift+Tabæ£€æµ‹å®ç°**

**æ–‡ä»¶è·¯å¾„**: `src/ui/hooks/use-keyboard-shortcuts.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * é”®ç›˜å¿«æ·é”®å¤„ç†Hook
 * åŸºäºé€†å‘åˆ†æchunks.100.mjs:2628-2636çš„é”®ç›˜äº‹ä»¶å¤„ç†
 */

import { useEffect, useCallback } from 'react';
import { PlanModeManager } from '../../core/plan-mode';

export interface KeyboardShortcutsConfig {
  planModeManager: PlanModeManager;
  onModeChange?: (mode: string) => void;
  isBypassPermissionsModeAvailable?: boolean;
}

/**
 * é”®ç›˜äº‹ä»¶æ¥å£ - å¯¹åº”é€†å‘åˆ†æä¸­çš„d0å¯¹è±¡
 */
interface KeyboardEvent {
  tab: boolean;
  shift: boolean;
  ctrl: boolean;
  alt: boolean;
  key: string;
}

export function useKeyboardShortcuts(config: KeyboardShortcutsConfig) {
  const { 
    planModeManager, 
    onModeChange, 
    isBypassPermissionsModeAvailable = false 
  } = config;

  /**
   * å¤„ç†Shift+Tabé”®ç»„åˆ - åŸºäºchunks.100.mjs:2628-2636
   */
  const handleShiftTab = useCallback(() => {
    const newMode = planModeManager.cyclePlanMode(isBypassPermissionsModeAvailable);
    
    if (onModeChange) {
      onModeChange(newMode);
    }
  }, [planModeManager, onModeChange, isBypassPermissionsModeAvailable]);

  /**
   * é”®ç›˜äº‹ä»¶å¤„ç†å™¨
   */
  const handleKeyDown = useCallback((event: globalThis.KeyboardEvent) => {
    // æ„å»ºé”®ç›˜äº‹ä»¶å¯¹è±¡ - å¯¹åº”d0
    const keyEvent: KeyboardEvent = {
      tab: event.key === 'Tab',
      shift: event.shiftKey,
      ctrl: event.ctrlKey,
      alt: event.altKey,
      key: event.key
    };

    // Shift+Tabæ£€æµ‹ - åŸºäºchunks.100.mjs:2628
    if (keyEvent.tab && keyEvent.shift) {
      event.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸º
      handleShiftTab();
      return;
    }

    // å…¶ä»–å¿«æ·é”®å¤„ç†...
  }, [handleShiftTab]);

  /**
   * æ³¨å†Œé”®ç›˜äº‹ä»¶ç›‘å¬å™¨
   */
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);

  /**
   * æ‰‹åŠ¨è§¦å‘æ¨¡å¼åˆ‡æ¢
   */
  const cyclePlanMode = useCallback(() => {
    handleShiftTab();
  }, [handleShiftTab]);

  return {
    cyclePlanMode,
    currentMode: planModeManager.getCurrentMode()
  };
}

/**
 * Planæ¨¡å¼é”®ç›˜å¿«æ·é”®ç»„ä»¶
 */
export interface PlanModeShortcutsProps {
  planModeManager: PlanModeManager;
  onModeChange?: (mode: string) => void;
}

export function PlanModeShortcuts({ planModeManager, onModeChange }: PlanModeShortcutsProps) {
  useKeyboardShortcuts({
    planModeManager,
    onModeChange
  });

  return null; // è¿™æ˜¯ä¸€ä¸ªé€»è¾‘ç»„ä»¶ï¼Œä¸æ¸²æŸ“UI
}
```

---

## ğŸ“ ç¬¬äºŒå‘¨ï¼šå®æ—¶Steeringå’Œç‰¹æ®Šäº¤äº’æ¨¡å¼

### æ­¥éª¤3.5: å®æ—¶Steeringæœºåˆ¶å¢å¼º

**é›†æˆh2Aæ¶ˆæ¯é˜Ÿåˆ—ä¸Planæ¨¡å¼**

**æ–‡ä»¶è·¯å¾„**: `src/core/steering-plan-integration.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * å®æ—¶Steeringä¸Planæ¨¡å¼é›†æˆ
 * æ‰©å±•h2Aå¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—ä»¥æ”¯æŒPlanæ¨¡å¼çš„å®æ—¶äº¤äº’
 */

import { h2A } from './message-queue';
import { PlanModeManager } from './plan-mode';

export interface SteeringMessage {
  type: 'user_input' | 'mode_change' | 'plan_approval' | 'plan_rejection';
  content: string;
  timestamp: number;
  sessionId: string;
  planContext?: {
    currentMode: string;
    plan?: string;
  };
}

export interface SteeringContext {
  planModeManager: PlanModeManager;
  sessionId: string;
  abortController: AbortController;
}

/**
 * Planæ¨¡å¼æ„ŸçŸ¥çš„Steeringæ¶ˆæ¯é˜Ÿåˆ—
 * æ‰©å±•h2Aç±»ä»¥æ”¯æŒPlanæ¨¡å¼çš„ç‰¹æ®Šå¤„ç†
 */
export class PlanAwareSteeringQueue extends h2A {
  private planModeManager: PlanModeManager;
  private stdinListening = false;
  
  constructor(planModeManager: PlanModeManager, cleanupFn?: () => void) {
    super(cleanupFn);
    this.planModeManager = planModeManager;
  }

  /**
   * å¯åŠ¨stdinç›‘å¬ - å¢å¼ºç‰ˆæœ¬æ”¯æŒPlanæ¨¡å¼
   */
  public startStdinListening(): void {
    if (this.stdinListening || typeof process === 'undefined') return;
    
    this.stdinListening = true;
    
    // é…ç½®stdinä¸ºåŸå§‹æ¨¡å¼
    if (process.stdin.setRawMode) {
      process.stdin.setRawMode(true);
    }
    process.stdin.resume();
    process.stdin.setEncoding('utf8');

    process.stdin.on('data', (chunk: string) => {
      this.handleStdinInput(chunk);
    });
  }

  /**
   * å¤„ç†stdinè¾“å…¥
   */
  private handleStdinInput(input: string): void {
    const steeringMessage: SteeringMessage = {
      type: 'user_input',
      content: input.trim(),
      timestamp: Date.now(),
      sessionId: this.planModeManager.getContext().sessionId,
      planContext: {
        currentMode: this.planModeManager.getCurrentMode()
      }
    };

    // Planæ¨¡å¼ä¸‹çš„ç‰¹æ®Šå¤„ç†
    if (this.planModeManager.isPlanMode()) {
      steeringMessage.planContext!.plan = "current_plan_content"; // å®é™…å®ç°ä¸­éœ€è¦è·å–å½“å‰è®¡åˆ’
      
      // æ£€æŸ¥æ˜¯å¦ä¸ºPlanæ¨¡å¼çš„ç‰¹æ®Šå‘½ä»¤
      if (this.isPlanModeCommand(input)) {
        this.handlePlanModeCommand(input, steeringMessage);
        return;
      }
    }

    // å°†æ¶ˆæ¯åŠ å…¥é˜Ÿåˆ—
    this.enqueue(steeringMessage);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºPlanæ¨¡å¼å‘½ä»¤
   */
  private isPlanModeCommand(input: string): boolean {
    const planCommands = [
      'exit plan',
      'approve plan', 
      'reject plan',
      'switch mode'
    ];
    
    return planCommands.some(cmd => 
      input.toLowerCase().includes(cmd)
    );
  }

  /**
   * å¤„ç†Planæ¨¡å¼ç‰¹æ®Šå‘½ä»¤
   */
  private handlePlanModeCommand(input: string, message: SteeringMessage): void {
    const lowerInput = input.toLowerCase();
    
    if (lowerInput.includes('exit plan') || lowerInput.includes('approve plan')) {
      message.type = 'plan_approval';
    } else if (lowerInput.includes('reject plan')) {
      message.type = 'plan_rejection';
    } else if (lowerInput.includes('switch mode')) {
      message.type = 'mode_change';
      // è‡ªåŠ¨åˆ‡æ¢æ¨¡å¼
      this.planModeManager.cyclePlanMode();
    }
    
    this.enqueue(message);
  }

  /**
   * åœæ­¢stdinç›‘å¬
   */
  public stopStdinListening(): void {
    if (!this.stdinListening) return;
    
    this.stdinListening = false;
    
    if (process.stdin.setRawMode) {
      process.stdin.setRawMode(false);
    }
    process.stdin.pause();
  }

  /**
   * è·å–Planæ¨¡å¼æ„ŸçŸ¥çš„æ¶ˆæ¯
   */
  public async getSteeringMessage(): Promise<SteeringMessage | null> {
    try {
      const result = await this.next();
      if (result.done) return null;
      
      return result.value as SteeringMessage;
    } catch (error) {
      console.error('Error getting steering message:', error);
      return null;
    }
  }
}

/**
 * Steeringæ¶ˆæ¯å¤„ç†å™¨
 * æ ¹æ®Planæ¨¡å¼çŠ¶æ€å¤„ç†ä¸åŒç±»å‹çš„ç”¨æˆ·è¾“å…¥
 */
export class SteeringMessageHandler {
  private planModeManager: PlanModeManager;
  
  constructor(planModeManager: PlanModeManager) {
    this.planModeManager = planModeManager;
  }

  /**
   * å¤„ç†Steeringæ¶ˆæ¯
   */
  public async handleMessage(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    switch (message.type) {
      case 'user_input':
        return this.handleUserInput(message);
      
      case 'mode_change':
        return this.handleModeChange(message);
      
      case 'plan_approval':
        return this.handlePlanApproval(message);
      
      case 'plan_rejection':
        return this.handlePlanRejection(message);
      
      default:
        return { shouldContinue: true };
    }
  }

  private async handleUserInput(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    if (this.planModeManager.isPlanMode()) {
      // Planæ¨¡å¼ä¸‹ï¼Œç”¨æˆ·è¾“å…¥ä½œä¸ºè®¡åˆ’ä¿®æ”¹å»ºè®®
      return {
        shouldContinue: true,
        response: `Plan mode active. Your input will be considered for plan refinement: "${message.content}"`,
        action: 'refine_plan'
      };
    }
    
    // é»˜è®¤æ¨¡å¼ä¸‹çš„æ­£å¸¸å¤„ç†
    return {
      shouldContinue: true,
      response: `Received steering input: "${message.content}"`,
      action: 'adjust_execution'
    };
  }

  private async handleModeChange(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    const newMode = this.planModeManager.getCurrentMode();
    
    return {
      shouldContinue: true,
      response: `Mode switched to: ${newMode}`,
      action: 'mode_changed'
    };
  }

  private async handlePlanApproval(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    // é€€å‡ºPlanæ¨¡å¼ï¼Œç»§ç»­æ‰§è¡Œ
    this.planModeManager.setMode("default", "user_approved_plan");
    
    return {
      shouldContinue: true,
      response: "Plan approved. Switching to execution mode.",
      action: 'execute_plan'
    };
  }

  private async handlePlanRejection(message: SteeringMessage): Promise<{
    shouldContinue: boolean;
    response?: string;
    action?: string;
  }> {
    return {
      shouldContinue: false,
      response: "Plan rejected. Please provide feedback for plan revision.",
      action: 'revise_plan'
    };
  }
}
```

### æ­¥éª¤3.6: ç‰¹æ®Šäº¤äº’æ¨¡å¼å®ç°

**åŸºäºé€†å‘åˆ†æçš„ç‰¹æ®Šæ¨¡å¼å¤„ç†**

**æ–‡ä»¶è·¯å¾„**: `src/ui/special-modes.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * ç‰¹æ®Šäº¤äº’æ¨¡å¼å¤„ç†
 * å®ç°!bashæ¨¡å¼ã€#ç¬”è®°æ¨¡å¼ã€å¤šè¡Œè¾“å…¥ç­‰ç‰¹æ®Šäº¤äº’
 */

export type SpecialMode = 'bash' | 'note' | 'multiline' | 'normal';

export interface SpecialModeContext {
  mode: SpecialMode;
  buffer: string[];
  startTime: number;
  metadata?: Record<string, any>;
}

export interface BashModeResult {
  command: string;
  output: string;
  exitCode: number;
  duration: number;
}

export interface NoteModeResult {
  content: string;
  timestamp: number;
  tags?: string[];
}

/**
 * ç‰¹æ®Šæ¨¡å¼å¤„ç†å™¨
 * åŸºäºClaude Codeçš„ç‰¹æ®Šäº¤äº’æ¨¡å¼å®ç°
 */
export class SpecialModeHandler {
  private currentContext: SpecialModeContext | null = null;
  private noteStorage: Map<string, NoteModeResult> = new Map();
  
  /**
   * æ£€æµ‹å¹¶å¤„ç†ç‰¹æ®Šæ¨¡å¼è¾“å…¥
   */
  public processInput(input: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
    context?: SpecialModeContext;
  } {
    // Bashæ¨¡å¼æ£€æµ‹ - !å‘½ä»¤
    if (input.startsWith('!')) {
      return this.handleBashMode(input.slice(1));
    }
    
    // ç¬”è®°æ¨¡å¼æ£€æµ‹ - #å†…å®¹
    if (input.startsWith('#')) {
      return this.handleNoteMode(input.slice(1));
    }
    
    // å¤šè¡Œè¾“å…¥æ£€æµ‹
    if (this.currentContext?.mode === 'multiline') {
      return this.handleMultilineMode(input);
    }
    
    // æ£€æŸ¥æ˜¯å¦å¼€å§‹å¤šè¡Œè¾“å…¥
    if (this.isMultilineStart(input)) {
      return this.startMultilineMode(input);
    }
    
    // æ™®é€šæ¨¡å¼
    return {
      mode: 'normal',
      content: input,
      shouldExecute: true
    };
  }

  /**
   * å¤„ç†Bashæ¨¡å¼ - !å‘½ä»¤ç›´æ¥æ‰§è¡Œ
   */
  private handleBashMode(command: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
  } {
    return {
      mode: 'bash',
      content: command.trim(),
      shouldExecute: true
    };
  }

  /**
   * æ‰§è¡ŒBashå‘½ä»¤
   */
  public async executeBashCommand(command: string): Promise<BashModeResult> {
    const startTime = Date.now();
    
    try {
      // è¿™é‡Œé›†æˆBashå·¥å…·æ‰§è¡Œ
      const { spawn } = await import('child_process');
      
      return new Promise((resolve, reject) => {
        const child = spawn('bash', ['-c', command], {
          stdio: ['pipe', 'pipe', 'pipe']
        });
        
        let stdout = '';
        let stderr = '';
        
        child.stdout.on('data', (data) => {
          stdout += data.toString();
        });
        
        child.stderr.on('data', (data) => {
          stderr += data.toString();
        });
        
        child.on('close', (code) => {
          resolve({
            command,
            output: stdout + stderr,
            exitCode: code || 0,
            duration: Date.now() - startTime
          });
        });
        
        child.on('error', (error) => {
          reject(error);
        });
        
        // 5ç§’è¶…æ—¶
        setTimeout(() => {
          child.kill();
          reject(new Error('Command timeout'));
        }, 5000);
      });
    } catch (error) {
      return {
        command,
        output: `Error: ${error}`,
        exitCode: 1,
        duration: Date.now() - startTime
      };
    }
  }

  /**
   * å¤„ç†ç¬”è®°æ¨¡å¼ - #å†…å®¹è®°å½•
   */
  private handleNoteMode(content: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
  } {
    const noteId = `note_${Date.now()}`;
    const noteResult: NoteModeResult = {
      content: content.trim(),
      timestamp: Date.now(),
      tags: this.extractTags(content)
    };
    
    this.noteStorage.set(noteId, noteResult);
    
    return {
      mode: 'note',
      content: `Note saved: ${content.trim()}`,
      shouldExecute: false // ç¬”è®°ä¸éœ€è¦æ‰§è¡Œ
    };
  }

  /**
   * æå–ç¬”è®°æ ‡ç­¾
   */
  private extractTags(content: string): string[] {
    const tagRegex = /#(\w+)/g;
    const tags: string[] = [];
    let match;
    
    while ((match = tagRegex.exec(content)) !== null) {
      tags.push(match[1]);
    }
    
    return tags;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¼€å§‹å¤šè¡Œè¾“å…¥
   */
  private isMultilineStart(input: string): boolean {
    // æ£€æµ‹å¤šè¡Œè¾“å…¥çš„å¼€å§‹æ ‡å¿—
    return input.includes('```') || 
           input.endsWith('\\') || 
           input.includes('"""') ||
           input.includes("'''");
  }

  /**
   * å¼€å§‹å¤šè¡Œè¾“å…¥æ¨¡å¼
   */
  private startMultilineMode(input: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
    context: SpecialModeContext;
  } {
    this.currentContext = {
      mode: 'multiline',
      buffer: [input],
      startTime: Date.now(),
      metadata: {
        delimiter: this.detectDelimiter(input)
      }
    };
    
    return {
      mode: 'multiline',
      content: input,
      shouldExecute: false,
      context: this.currentContext
    };
  }

  /**
   * æ£€æµ‹å¤šè¡Œåˆ†éš”ç¬¦
   */
  private detectDelimiter(input: string): string {
    if (input.includes('```')) return '```';
    if (input.includes('"""')) return '"""';
    if (input.includes("'''")) return "'''";
    if (input.endsWith('\\')) return '\\';
    return '';
  }

  /**
   * å¤„ç†å¤šè¡Œè¾“å…¥æ¨¡å¼
   */
  private handleMultilineMode(input: string): {
    mode: SpecialMode;
    content: string;
    shouldExecute: boolean;
    context?: SpecialModeContext;
  } {
    if (!this.currentContext) {
      throw new Error('No multiline context');
    }
    
    this.currentContext.buffer.push(input);
    
    // æ£€æŸ¥æ˜¯å¦ç»“æŸå¤šè¡Œè¾“å…¥
    const delimiter = this.currentContext.metadata?.delimiter || '';
    if (this.isMultilineEnd(input, delimiter)) {
      const fullContent = this.currentContext.buffer.join('\n');
      this.currentContext = null; // æ¸…é™¤ä¸Šä¸‹æ–‡
      
      return {
        mode: 'normal',
        content: fullContent,
        shouldExecute: true
      };
    }
    
    return {
      mode: 'multiline',
      content: input,
      shouldExecute: false,
      context: this.currentContext
    };
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ç»“æŸå¤šè¡Œè¾“å…¥
   */
  private isMultilineEnd(input: string, delimiter: string): boolean {
    if (delimiter === '```' || delimiter === '"""' || delimiter === "'''") {
      return input.trim() === delimiter;
    }
    
    if (delimiter === '\\') {
      return !input.endsWith('\\');
    }
    
    return false;
  }

  /**
   * è·å–æ‰€æœ‰ç¬”è®°
   */
  public getNotes(): NoteModeResult[] {
    return Array.from(this.noteStorage.values()).sort((a, b) => b.timestamp - a.timestamp);
  }

  /**
   * æœç´¢ç¬”è®°
   */
  public searchNotes(query: string): NoteModeResult[] {
    const notes = this.getNotes();
    const lowerQuery = query.toLowerCase();
    
    return notes.filter(note => 
      note.content.toLowerCase().includes(lowerQuery) ||
      note.tags?.some(tag => tag.toLowerCase().includes(lowerQuery))
    );
  }

  /**
   * æ¸…é™¤å½“å‰å¤šè¡Œä¸Šä¸‹æ–‡
   */
  public clearMultilineContext(): void {
    this.currentContext = null;
  }

  /**
   * è·å–å½“å‰æ¨¡å¼çŠ¶æ€
   */
  public getCurrentModeStatus(): {
    mode: SpecialMode;
    isActive: boolean;
    buffer?: string[];
    duration?: number;
  } {
    if (!this.currentContext) {
      return { mode: 'normal', isActive: false };
    }
    
    return {
      mode: this.currentContext.mode,
      isActive: true,
      buffer: this.currentContext.buffer,
      duration: Date.now() - this.currentContext.startTime
    };
  }
}

/**
 * ç‰¹æ®Šæ¨¡å¼UIç»„ä»¶
 */
export interface SpecialModeIndicatorProps {
  handler: SpecialModeHandler;
  theme: any;
}

export function SpecialModeIndicator({ handler, theme }: SpecialModeIndicatorProps): React.ReactElement | null {
  const status = handler.getCurrentModeStatus();
  
  if (!status.isActive) {
    return null;
  }
  
  const getModeIcon = (mode: SpecialMode): string => {
    switch (mode) {
      case 'bash': return 'ğŸ’»';
      case 'note': return 'ğŸ“';
      case 'multiline': return 'ğŸ“„';
      default: return 'â­';
    }
  };
  
  const getModeLabel = (mode: SpecialMode): string => {
    switch (mode) {
      case 'bash': return 'Bash Mode';
      case 'note': return 'Note Mode';
      case 'multiline': return 'Multi-line Input';
      default: return 'Special Mode';
    }
  };
  
  return (
    <div style={{
      display: 'flex',
      alignItems: 'center',
      padding: '2px 6px',
      backgroundColor: theme.specialModeBackground,
      borderRadius: 3,
      fontSize: '0.85em'
    }}>
      <span style={{ marginRight: 4 }}>
        {getModeIcon(status.mode)}
      </span>
      <span style={{ color: theme.specialModeText }}>
        {getModeLabel(status.mode)}
      </span>
      {status.mode === 'multiline' && (
        <span style={{ 
          color: theme.secondaryText,
          marginLeft: 4,
          fontSize: '0.8em'
        }}>
          ({status.buffer?.length || 0} lines)
        </span>
      )}
    </div>
  );
}
```

---

## ğŸ“ ç¬¬ä¸‰å‘¨ï¼šå¿«æ·æŒ‡ä»¤ç³»ç»Ÿå’ŒIDEé›†æˆ

### æ­¥éª¤3.7: å¿«æ·æŒ‡ä»¤ç³»ç»Ÿå®ç°

**å®Œæ•´çš„æ–œæ å‘½ä»¤å¤„ç†ç³»ç»Ÿ**

**æ–‡ä»¶è·¯å¾„**: `src/commands/slash-commands.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * å¿«æ·æŒ‡ä»¤ç³»ç»Ÿå®ç°
 * åŸºäºClaude Codeçš„æ–œæ å‘½ä»¤åŠŸèƒ½
 */

export interface SlashCommand {
  name: string;
  description: string;
  usage: string;
  execute: (args: string[], context: CommandContext) => Promise<CommandResult>;
  permissions?: string[];
  aliases?: string[];
}

export interface CommandContext {
  sessionId: string;
  userId?: string;
  mcpServers: any[];
  currentDirectory: string;
  planModeManager: any;
}

export interface CommandResult {
  success: boolean;
  message: string;
  data?: any;
  shouldContinue?: boolean;
}

/**
 * å¿«æ·æŒ‡ä»¤ç®¡ç†å™¨
 */
export class SlashCommandManager {
  private commands = new Map<string, SlashCommand>();
  private aliases = new Map<string, string>();
  
  constructor() {
    this.registerBuiltinCommands();
  }

  /**
   * æ³¨å†Œå†…ç½®å‘½ä»¤
   */
  private registerBuiltinCommands(): void {
    // /help - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
    this.register({
      name: 'help',
      description: 'Show available commands and usage',
      usage: '/help [command]',
      execute: async (args, context) => {
        if (args.length > 0) {
          return this.showCommandHelp(args[0]);
        }
        return this.showAllCommands();
      }
    });

    // /login - ç”¨æˆ·è®¤è¯ç®¡ç†
    this.register({
      name: 'login',
      description: 'Authenticate with Claude Code services',
      usage: '/login [provider]',
      execute: async (args, context) => {
        return await this.handleLogin(args, context);
      }
    });

    // /logout - æ³¨é”€å½“å‰ç”¨æˆ·
    this.register({
      name: 'logout',
      description: 'Sign out from current session',
      usage: '/logout',
      execute: async (args, context) => {
        return await this.handleLogout(context);
      }
    });

    // /clear - æ¸…é™¤å¯¹è¯å†å²
    this.register({
      name: 'clear',
      description: 'Clear conversation history',
      usage: '/clear',
      aliases: ['cls'],
      execute: async (args, context) => {
        return {
          success: true,
          message: 'Conversation history cleared',
          data: { action: 'clear_history' }
        };
      }
    });

    // /resume - æ¢å¤å†å²ä¼šè¯
    this.register({
      name: 'resume',
      description: 'Resume a previous session',
      usage: '/resume <session_id>',
      execute: async (args, context) => {
        if (args.length === 0) {
          return {
            success: false,
            message: 'Session ID required. Usage: /resume <session_id>'
          };
        }
        return await this.handleResume(args[0], context);
      }
    });

    // /mcp - MCPæœåŠ¡å™¨ç®¡ç†
    this.register({
      name: 'mcp',
      description: 'Manage MCP servers',
      usage: '/mcp <action> [server_name]',
      execute: async (args, context) => {
        return await this.handleMcpCommand(args, context);
      }
    });

    // /review - AIä»£ç å®¡æŸ¥
    this.register({
      name: 'review',
      description: 'Start AI code review',
      usage: '/review [file_pattern]',
      execute: async (args, context) => {
        return await this.handleCodeReview(args, context);
      }
    });

    // /status - ç³»ç»ŸçŠ¶æ€æ˜¾ç¤º
    this.register({
      name: 'status',
      description: 'Show system status and diagnostics',
      usage: '/status',
      execute: async (args, context) => {
        return await this.handleStatus(context);
      }
    });

    // /mode - æ¨¡å¼ç®¡ç†
    this.register({
      name: 'mode',
      description: 'Switch between interaction modes',
      usage: '/mode [plan|default|acceptEdits]',
      execute: async (args, context) => {
        return await this.handleModeSwitch(args, context);
      }
    });

    // /config - é…ç½®ç®¡ç†
    this.register({
      name: 'config',
      description: 'View or modify configuration',
      usage: '/config [get|set] [key] [value]',
      execute: async (args, context) => {
        return await this.handleConfig(args, context);
      }
    });

    // /debug - è°ƒè¯•ä¿¡æ¯
    this.register({
      name: 'debug',
      description: 'Show debug information',
      usage: '/debug [component]',
      execute: async (args, context) => {
        return await this.handleDebug(args, context);
      }
    });

    // /export - å¯¼å‡ºä¼šè¯
    this.register({
      name: 'export',
      description: 'Export conversation or data',
      usage: '/export [format] [target]',
      execute: async (args, context) => {
        return await this.handleExport(args, context);
      }
    });

    // /import - å¯¼å…¥æ•°æ®
    this.register({
      name: 'import',
      description: 'Import configuration or data',
      usage: '/import <source>',
      execute: async (args, context) => {
        return await this.handleImport(args, context);
      }
    });

    // /workspace - å·¥ä½œåŒºç®¡ç†
    this.register({
      name: 'workspace',
      description: 'Manage workspace settings',
      usage: '/workspace [action]',
      aliases: ['ws'],
      execute: async (args, context) => {
        return await this.handleWorkspace(args, context);
      }
    });

    // /tools - å·¥å…·ç®¡ç†
    this.register({
      name: 'tools',
      description: 'List and manage available tools',
      usage: '/tools [list|enable|disable] [tool_name]',
      execute: async (args, context) => {
        return await this.handleTools(args, context);
      }
    });

    // /session - ä¼šè¯ç®¡ç†
    this.register({
      name: 'session',
      description: 'Session management commands',
      usage: '/session [new|save|load|list]',
      execute: async (args, context) => {
        return await this.handleSession(args, context);
      }
    });
  }

  /**
   * æ³¨å†Œå‘½ä»¤
   */
  public register(command: SlashCommand): void {
    this.commands.set(command.name, command);
    
    // æ³¨å†Œåˆ«å
    if (command.aliases) {
      for (const alias of command.aliases) {
        this.aliases.set(alias, command.name);
      }
    }
  }

  /**
   * è§£æå’Œæ‰§è¡Œå‘½ä»¤
   */
  public async execute(input: string, context: CommandContext): Promise<CommandResult> {
    if (!input.startsWith('/')) {
      return {
        success: false,
        message: 'Not a slash command'
      };
    }

    const parts = input.slice(1).split(' ');
    const commandName = parts[0].toLowerCase();
    const args = parts.slice(1);

    // æ£€æŸ¥åˆ«å
    const actualCommand = this.aliases.get(commandName) || commandName;
    const command = this.commands.get(actualCommand);

    if (!command) {
      return {
        success: false,
        message: `Unknown command: /${commandName}. Type /help for available commands.`
      };
    }

    try {
      return await command.execute(args, context);
    } catch (error) {
      return {
        success: false,
        message: `Error executing command: ${error}`
      };
    }
  }

  /**
   * æ£€æŸ¥æ˜¯å¦ä¸ºæ–œæ å‘½ä»¤
   */
  public isSlashCommand(input: string): boolean {
    return input.trim().startsWith('/');
  }

  /**
   * è·å–å‘½ä»¤è‡ªåŠ¨è¡¥å…¨
   */
  public getCompletions(partial: string): string[] {
    const commandPart = partial.slice(1).toLowerCase();
    const completions: string[] = [];

    for (const [name, command] of this.commands) {
      if (name.startsWith(commandPart)) {
        completions.push(`/${name}`);
      }
    }

    for (const [alias, commandName] of this.aliases) {
      if (alias.startsWith(commandPart)) {
        completions.push(`/${alias}`);
      }
    }

    return completions.sort();
  }

  // å‘½ä»¤å®ç°æ–¹æ³•...
  private async showAllCommands(): Promise<CommandResult> {
    const commandList = Array.from(this.commands.values())
      .map(cmd => `/${cmd.name} - ${cmd.description}`)
      .join('\n');

    return {
      success: true,
      message: `Available commands:\n${commandList}\n\nType /help <command> for detailed usage.`
    };
  }

  private async showCommandHelp(commandName: string): Promise<CommandResult> {
    const actualCommand = this.aliases.get(commandName) || commandName;
    const command = this.commands.get(actualCommand);

    if (!command) {
      return {
        success: false,
        message: `Command not found: /${commandName}`
      };
    }

    let helpText = `Command: /${command.name}\n`;
    helpText += `Description: ${command.description}\n`;
    helpText += `Usage: ${command.usage}`;

    if (command.aliases?.length) {
      helpText += `\nAliases: ${command.aliases.map(a => `/${a}`).join(', ')}`;
    }

    return {
      success: true,
      message: helpText
    };
  }

  private async handleLogin(args: string[], context: CommandContext): Promise<CommandResult> {
    // å®ç°ç™»å½•é€»è¾‘
    return {
      success: true,
      message: 'Login initiated. Please check your browser for authentication.',
      data: { action: 'start_oauth' }
    };
  }

  private async handleLogout(context: CommandContext): Promise<CommandResult> {
    // å®ç°ç™»å‡ºé€»è¾‘
    return {
      success: true,
      message: 'Successfully logged out.',
      data: { action: 'clear_auth' }
    };
  }

  private async handleResume(sessionId: string, context: CommandContext): Promise<CommandResult> {
    // å®ç°ä¼šè¯æ¢å¤é€»è¾‘
    return {
      success: true,
      message: `Resuming session: ${sessionId}`,
      data: { action: 'resume_session', sessionId }
    };
  }

  private async handleMcpCommand(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      const serverList = context.mcpServers.map(s => `- ${s.name} (${s.status})`).join('\n');
      return {
        success: true,
        message: `MCP Servers:\n${serverList}`
      };
    }

    const action = args[0];
    const serverName = args[1];

    switch (action) {
      case 'list':
        const servers = context.mcpServers.map(s => 
          `${s.name}: ${s.status} (${s.tools?.length || 0} tools)`
        ).join('\n');
        return {
          success: true,
          message: `MCP Servers:\n${servers}`
        };

      case 'restart':
        if (!serverName) {
          return { success: false, message: 'Server name required' };
        }
        return {
          success: true,
          message: `Restarting MCP server: ${serverName}`,
          data: { action: 'restart_mcp_server', serverName }
        };

      default:
        return {
          success: false,
          message: 'Unknown MCP action. Available: list, restart'
        };
    }
  }

  private async handleCodeReview(args: string[], context: CommandContext): Promise<CommandResult> {
    const pattern = args[0] || '**/*.{js,ts,jsx,tsx,py}';
    
    return {
      success: true,
      message: `Starting code review for pattern: ${pattern}`,
      data: { action: 'start_code_review', pattern }
    };
  }

  private async handleStatus(context: CommandContext): Promise<CommandResult> {
    const status = {
      session: context.sessionId,
      mode: context.planModeManager?.getCurrentMode() || 'default',
      mcpServers: context.mcpServers.length,
      workingDirectory: context.currentDirectory
    };

    const statusText = Object.entries(status)
      .map(([key, value]) => `${key}: ${value}`)
      .join('\n');

    return {
      success: true,
      message: `System Status:\n${statusText}`
    };
  }

  private async handleModeSwitch(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      const currentMode = context.planModeManager?.getCurrentMode() || 'default';
      return {
        success: true,
        message: `Current mode: ${currentMode}\nAvailable modes: default, acceptEdits, plan, bypassPermissions`
      };
    }

    const targetMode = args[0];
    const validModes = ['default', 'acceptEdits', 'plan', 'bypassPermissions'];

    if (!validModes.includes(targetMode)) {
      return {
        success: false,
        message: `Invalid mode. Available modes: ${validModes.join(', ')}`
      };
    }

    context.planModeManager?.setMode(targetMode, 'slash_command');

    return {
      success: true,
      message: `Switched to ${targetMode} mode`,
      data: { action: 'mode_change', mode: targetMode }
    };
  }

  private async handleConfig(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      return {
        success: true,
        message: 'Configuration commands: get, set, list\nUsage: /config get <key> or /config set <key> <value>'
      };
    }

    const action = args[0];
    switch (action) {
      case 'list':
        return {
          success: true,
          message: 'Available configuration keys:\n- model\n- theme\n- autoSave\n- debugMode',
          data: { action: 'list_config' }
        };

      case 'get':
        const key = args[1];
        if (!key) {
          return { success: false, message: 'Configuration key required' };
        }
        return {
          success: true,
          message: `Configuration value for ${key}: [value would be shown here]`,
          data: { action: 'get_config', key }
        };

      case 'set':
        const setKey = args[1];
        const value = args.slice(2).join(' ');
        if (!setKey || !value) {
          return { success: false, message: 'Both key and value required' };
        }
        return {
          success: true,
          message: `Set ${setKey} = ${value}`,
          data: { action: 'set_config', key: setKey, value }
        };

      default:
        return { success: false, message: 'Unknown config action' };
    }
  }

  private async handleDebug(args: string[], context: CommandContext): Promise<CommandResult> {
    const component = args[0] || 'all';
    
    const debugInfo = {
      timestamp: new Date().toISOString(),
      component,
      sessionId: context.sessionId,
      memoryUsage: process.memoryUsage?.() || 'N/A',
      uptime: process.uptime?.() || 'N/A'
    };

    return {
      success: true,
      message: `Debug information for ${component}:\n${JSON.stringify(debugInfo, null, 2)}`,
      data: { action: 'debug_info', debugInfo }
    };
  }

  private async handleExport(args: string[], context: CommandContext): Promise<CommandResult> {
    const format = args[0] || 'json';
    const target = args[1] || 'conversation';

    return {
      success: true,
      message: `Exporting ${target} in ${format} format...`,
      data: { action: 'export_data', format, target }
    };
  }

  private async handleImport(args: string[], context: CommandContext): Promise<CommandResult> {
    if (args.length === 0) {
      return { success: false, message: 'Import source required' };
    }

    const source = args[0];
    return {
      success: true,
      message: `Importing from ${source}...`,
      data: { action: 'import_data', source }
    };
  }

  private async handleWorkspace(args: string[], context: CommandContext): Promise<CommandResult> {
    const action = args[0] || 'status';

    switch (action) {
      case 'status':
        return {
          success: true,
          message: `Workspace: ${context.currentDirectory}\nActive tools: [tool list would be shown here]`
        };

      case 'reload':
        return {
          success: true,
          message: 'Reloading workspace configuration...',
          data: { action: 'reload_workspace' }
        };

      default:
        return { success: false, message: 'Unknown workspace action' };
    }
  }

  private async handleTools(args: string[], context: CommandContext): Promise<CommandResult> {
    const action = args[0] || 'list';

    switch (action) {
      case 'list':
        return {
          success: true,
          message: 'Available tools:\n- Read\n- Write\n- Edit\n- Bash\n- Grep\n- [... other tools]'
        };

      default:
        return { success: false, message: 'Unknown tools action' };
    }
  }

  private async handleSession(args: string[], context: CommandContext): Promise<CommandResult> {
    const action = args[0] || 'info';

    switch (action) {
      case 'info':
        return {
          success: true,
          message: `Current session: ${context.sessionId}\nStarted: [timestamp would be shown here]`
        };

      case 'new':
        return {
          success: true,
          message: 'Creating new session...',
          data: { action: 'new_session' }
        };

      case 'save':
        return {
          success: true,
          message: 'Session saved successfully',
          data: { action: 'save_session' }
        };

      default:
        return { success: false, message: 'Unknown session action' };
    }
  }
}
```

### æ­¥éª¤3.8: IDEè¯Šæ–­ä¿¡æ¯ç®¡ç†ç³»ç»Ÿ

**åŸºäºé€†å‘åˆ†æçš„PKç±»å®Œæ•´å®ç°**

**æ–‡ä»¶è·¯å¾„**: `src/integrations/ide-diagnostics.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * IDEè¯Šæ–­ä¿¡æ¯ç®¡ç†ç³»ç»Ÿ
 * åŸºäºé€†å‘åˆ†æchunks.92.mjsçš„PKç±»ç²¾ç¡®å®ç°
 */

export interface DiagnosticInfo {
  uri: string;
  diagnostics: LspDiagnostic[];
}

export interface LspDiagnostic {
  message: string;
  severity: number;
  source?: string;
  code?: string | number;
  range: {
    start: { line: number; character: number };
    end: { line: number; character: number };
  };
}

export interface McpClient {
  type: 'connected' | 'disconnected';
  callTool: (toolName: string, params: any) => Promise<any>;
}

/**
 * PK - è¯Šæ–­ä¿¡æ¯ç®¡ç†å™¨
 * åŸºäºchunks.92.mjs:49-59çš„å•ä¾‹æ¨¡å¼å®ç°
 */
export class IdeDiagnosticsManager {
  private static instance: IdeDiagnosticsManager;
  
  private baseline = new Map<string, LspDiagnostic[]>();           // åŸºçº¿è¯Šæ–­ä¿¡æ¯
  private initialized = false;                                    // åˆå§‹åŒ–çŠ¶æ€
  private mcpClient: McpClient | null = null;                    // MCPå®¢æˆ·ç«¯
  private lastProcessedTimestamps = new Map<string, number>();   // æœ€åå¤„ç†æ—¶é—´æˆ³
  private lastDiagnosticsByUri = new Map<string, LspDiagnostic[]>(); // æœ€åè¯Šæ–­ä¿¡æ¯
  private rightFileDiagnosticsState = new Map<string, LspDiagnostic[]>(); // å³ä¾§æ–‡ä»¶è¯Šæ–­çŠ¶æ€

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): IdeDiagnosticsManager {
    if (!IdeDiagnosticsManager.instance) {
      IdeDiagnosticsManager.instance = new IdeDiagnosticsManager();
    }
    return IdeDiagnosticsManager.instance;
  }

  /**
   * åˆå§‹åŒ–è¯Šæ–­ç®¡ç†å™¨
   */
  public initialize(mcpClient: McpClient): void {
    this.mcpClient = mcpClient;
    this.initialized = true;
  }

  /**
   * æ–‡ä»¶ç¼–è¾‘å‰è·å–è¯Šæ–­åŸºçº¿ - åŸºäºchunks.92.mjs:109-119
   */
  public async beforeFileEdited(filePath: string): Promise<void> {
    if (!this.initialized || !this.mcpClient || this.mcpClient.type !== "connected") {
      return;
    }

    const timestamp = Date.now();
    
    try {
      const result = await this.callDiagnosticsTool("getDiagnostics", {
        uri: `file://${filePath}`
      });
      
      const diagnostics = this.parseDiagnosticResult(result);
      const fileInfo = diagnostics[0];
      
      if (fileInfo) {
        if (filePath !== this.normalizeFileUri(fileInfo.uri)) {
          throw new Error(`Diagnostics file path mismatch: expected ${filePath}, got ${fileInfo.uri})`);
        }
        
        this.baseline.set(filePath, fileInfo.diagnostics);
        this.lastProcessedTimestamps.set(filePath, timestamp);
      } else {
        this.baseline.set(filePath, []);
        this.lastProcessedTimestamps.set(filePath, timestamp);
      }
    } catch (error) {
      console.error('Error getting baseline diagnostics:', error);
    }
  }

  /**
   * è·å–æ–°çš„è¯Šæ–­ä¿¡æ¯ - åŸºäºchunks.92.mjs:122-155
   */
  public async getNewDiagnostics(): Promise<DiagnosticInfo[]> {
    if (!this.initialized || !this.mcpClient || this.mcpClient.type !== "connected") {
      return [];
    }

    let allDiagnostics: DiagnosticInfo[] = [];
    
    try {
      const result = await this.callDiagnosticsTool("getDiagnostics", {});
      allDiagnostics = this.parseDiagnosticResult(result);
    } catch (error) {
      console.error('Error getting diagnostics:', error);
      return [];
    }

    // åˆ†ç¦»æœ¬åœ°æ–‡ä»¶å’Œå³ä¾§æ–‡ä»¶çš„è¯Šæ–­ä¿¡æ¯
    const localFiles = allDiagnostics
      .filter(info => this.baseline.has(this.normalizeFileUri(info.uri)))
      .filter(info => info.uri.startsWith("file://"));

    const rightFileMap = new Map<string, DiagnosticInfo>();
    allDiagnostics
      .filter(info => this.baseline.has(this.normalizeFileUri(info.uri)))
      .filter(info => info.uri.startsWith("_claude_fs_right:"))
      .forEach(info => {
        rightFileMap.set(this.normalizeFileUri(info.uri), info);
      });

    // æ¯”è¾ƒè¯Šæ–­ä¿¡æ¯å˜åŒ–
    const newDiagnostics: DiagnosticInfo[] = [];
    
    for (const info of localFiles) {
      const normalizedUri = this.normalizeFileUri(info.uri);
      const baselineDiagnostics = this.baseline.get(normalizedUri) || [];
      const rightFileInfo = rightFileMap.get(normalizedUri);
      let currentInfo = info;

      if (rightFileInfo) {
        const previousRightState = this.rightFileDiagnosticsState.get(normalizedUri);
        if (!previousRightState || !this.areDiagnosticArraysEqual(previousRightState, rightFileInfo.diagnostics)) {
          currentInfo = rightFileInfo;
        }
        this.rightFileDiagnosticsState.set(normalizedUri, rightFileInfo.diagnostics);
      }

      const newDiagnosticsForFile = currentInfo.diagnostics.filter(diag => 
        !baselineDiagnostics.some(baseline => this.areDiagnosticsEqual(diag, baseline))
      );

      if (newDiagnosticsForFile.length > 0) {
        newDiagnostics.push({
          uri: info.uri,
          diagnostics: newDiagnosticsForFile
        });
      }

      this.baseline.set(normalizedUri, currentInfo.diagnostics);
    }

    return newDiagnostics;
  }

  /**
   * è§£æè¯Šæ–­ç»“æœ - åŸºäºchunks.92.mjs:156-162
   */
  private parseDiagnosticResult(result: any): DiagnosticInfo[] {
    if (Array.isArray(result)) {
      const textResult = result.find(item => item.type === "text");
      if (textResult && "text" in textResult) {
        return JSON.parse(textResult.text);
      }
    }
    return [];
  }

  /**
   * æ¯”è¾ƒè¯Šæ–­ä¿¡æ¯æ˜¯å¦ç›¸ç­‰ - åŸºäºchunks.92.mjs:163-169
   */
  private areDiagnosticsEqual(a: LspDiagnostic, b: LspDiagnostic): boolean {
    return a.message === b.message && 
           a.severity === b.severity && 
           a.source === b.source && 
           a.code === b.code && 
           a.range.start.line === b.range.start.line && 
           a.range.start.character === b.range.start.character && 
           a.range.end.line === b.range.end.line && 
           a.range.end.character === b.range.end.character;
  }

  /**
   * æ¯”è¾ƒè¯Šæ–­æ•°ç»„æ˜¯å¦ç›¸ç­‰
   */
  private areDiagnosticArraysEqual(a: LspDiagnostic[], b: LspDiagnostic[]): boolean {
    if (a.length !== b.length) return false;
    
    return a.every(diagA => b.some(diagB => this.areDiagnosticsEqual(diagA, diagB))) && 
           b.every(diagB => a.some(diagA => this.areDiagnosticsEqual(diagA, diagB)));
  }

  /**
   * æ ‡å‡†åŒ–æ–‡ä»¶URI
   */
  private normalizeFileUri(uri: string): string {
    if (uri.startsWith("file://")) {
      return uri.replace("file://", "");
    }
    if (uri.startsWith("_claude_fs_right:")) {
      return uri.replace("_claude_fs_right:", "");
    }
    return uri;
  }

  /**
   * è°ƒç”¨è¯Šæ–­å·¥å…·
   */
  private async callDiagnosticsTool(toolName: string, params: any): Promise<any> {
    if (!this.mcpClient) {
      throw new Error('MCP client not initialized');
    }
    
    return await this.mcpClient.callTool(`mcp__ide__${toolName}`, params);
  }

  /**
   * è·å–åŸºçº¿è¯Šæ–­ä¿¡æ¯
   */
  public getBaselineDiagnostics(filePath: string): LspDiagnostic[] {
    return this.baseline.get(filePath) || [];
  }

  /**
   * æ¸…é™¤è¯Šæ–­åŸºçº¿
   */
  public clearBaseline(filePath?: string): void {
    if (filePath) {
      this.baseline.delete(filePath);
      this.lastProcessedTimestamps.delete(filePath);
      this.rightFileDiagnosticsState.delete(filePath);
    } else {
      this.baseline.clear();
      this.lastProcessedTimestamps.clear();
      this.rightFileDiagnosticsState.clear();
    }
  }

  /**
   * è·å–æ‰€æœ‰è·Ÿè¸ªçš„æ–‡ä»¶
   */
  public getTrackedFiles(): string[] {
    return Array.from(this.baseline.keys());
  }

  /**
   * è·å–è¯Šæ–­ç»Ÿè®¡ä¿¡æ¯
   */
  public getDiagnosticsStatistics(): {
    totalFiles: number;
    totalDiagnostics: number;
    errorCount: number;
    warningCount: number;
    infoCount: number;
  } {
    let totalDiagnostics = 0;
    let errorCount = 0;
    let warningCount = 0;
    let infoCount = 0;

    for (const diagnostics of this.baseline.values()) {
      totalDiagnostics += diagnostics.length;
      
      for (const diag of diagnostics) {
        switch (diag.severity) {
          case 1: errorCount++; break;      // Error
          case 2: warningCount++; break;    // Warning
          case 3: 
          case 4: infoCount++; break;       // Information/Hint
        }
      }
    }

    return {
      totalFiles: this.baseline.size,
      totalDiagnostics,
      errorCount,
      warningCount,
      infoCount
    };
  }
}

/**
 * IDEè¿æ¥æ£€æµ‹å™¨
 * åŸºäºé€†å‘åˆ†æchunks.33585-33588çš„TF1å‡½æ•°å®ç°
 */
export class IdeConnectionDetector {
  /**
   * æ£€æµ‹è¿æ¥çš„IDEç±»å‹ - åŸºäºTF1å‡½æ•°
   */
  public static detectConnectedIde(mcpServers: any[]): string | null {
    const ideServer = mcpServers.find(server => 
      server.type === "connected" && server.name === "ide"
    )?.config;
    
    if (ideServer?.type === "sse-ide" || ideServer?.type === "ws-ide") {
      return ideServer.ideName;
    }
    
    return null;
  }

  /**
   * è·å–IDEæ˜¾ç¤ºåç§°
   */
  public static getIdeDisplayName(ideName: string): string {
    switch (ideName) {
      case "vscode":
        return "VS Code";
      case "cursor":
        return "Cursor";
      case "windsurf":
        return "Windsurf";
      default:
        return ideName;
    }
  }

  /**
   * æ£€æŸ¥IDEåŠŸèƒ½æ”¯æŒ
   */
  public static getIdeCapabilities(ideName: string): {
    supportsExecuteCode: boolean;
    supportsGetDiagnostics: boolean;
    supportsShiftEnter: boolean;
  } {
    const supportedIdes = ["vscode", "cursor", "windsurf"];
    const isSupported = supportedIdes.includes(ideName);
    
    return {
      supportsExecuteCode: isSupported,
      supportsGetDiagnostics: isSupported,
      supportsShiftEnter: ["iTerm.app", "vscode", "cursor", "windsurf", "ghostty"].includes(ideName)
    };
  }
}

/**
 * è¯Šæ–­ä¿¡æ¯UIç»„ä»¶
 */
export interface DiagnosticsDisplayProps {
  diagnostics: DiagnosticInfo[];
  theme: any;
}

export function DiagnosticsDisplay({ diagnostics, theme }: DiagnosticsDisplayProps): React.ReactElement | null {
  if (diagnostics.length === 0) {
    return null;
  }

  const getSeverityIcon = (severity: number): string => {
    switch (severity) {
      case 1: return "âŒ"; // Error
      case 2: return "âš ï¸"; // Warning
      case 3: return "â„¹ï¸"; // Information
      case 4: return "ğŸ’¡"; // Hint
      default: return "ğŸ“";
    }
  };

  const getSeverityColor = (severity: number): string => {
    switch (severity) {
      case 1: return theme.error;
      case 2: return theme.warning;
      case 3: return theme.info;
      case 4: return theme.hint;
      default: return theme.primaryText;
    }
  };

  return (
    <div style={{
      backgroundColor: theme.diagnosticsBackground,
      borderRadius: 4,
      padding: 8,
      marginTop: 8
    }}>
      <div style={{
        color: theme.primaryText,
        fontWeight: 'bold',
        marginBottom: 8
      }}>
        ğŸ” New Diagnostics Found
      </div>
      
      {diagnostics.map((fileInfo, index) => (
        <div key={index} style={{ marginBottom: 12 }}>
          <div style={{
            color: theme.secondaryText,
            fontSize: '0.9em',
            marginBottom: 4
          }}>
            ğŸ“ {fileInfo.uri.replace('file://', '')}
          </div>
          
          {fileInfo.diagnostics.map((diag, diagIndex) => (
            <div key={diagIndex} style={{
              display: 'flex',
              alignItems: 'flex-start',
              marginBottom: 4,
              paddingLeft: 16
            }}>
              <span style={{ marginRight: 8 }}>
                {getSeverityIcon(diag.severity)}
              </span>
              <div style={{ flex: 1 }}>
                <div style={{
                  color: getSeverityColor(diag.severity),
                  fontSize: '0.9em'
                }}>
                  Line {diag.range.start.line + 1}: {diag.message}
                </div>
                {diag.source && (
                  <div style={{
                    color: theme.secondaryText,
                    fontSize: '0.8em'
                  }}>
                    Source: {diag.source}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      ))}
    </div>
  );
}
```

### æ­¥éª¤3.9: é›†æˆæµ‹è¯•å’ŒéªŒè¯

**åˆ›å»ºå®Œæ•´çš„é›†æˆæµ‹è¯•å¥—ä»¶**

**æ–‡ä»¶è·¯å¾„**: `src/__tests__/stage3-integration.test.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * é˜¶æ®µ3é›†æˆæµ‹è¯•å¥—ä»¶
 * éªŒè¯Planæ¨¡å¼ã€Steeringæœºåˆ¶ã€ç‰¹æ®Šäº¤äº’æ¨¡å¼å’ŒIDEé›†æˆçš„å®Œæ•´åŠŸèƒ½
 */

import { describe, test, expect, beforeEach, afterEach } from '@jest/testing-library';
import { PlanModeManager, wj2 } from '../core/plan-mode';
import { PlanAwareSteeringQueue, SteeringMessageHandler } from '../core/steering-plan-integration';
import { SpecialModeHandler } from '../ui/special-modes';
import { SlashCommandManager } from '../commands/slash-commands';
import { IdeDiagnosticsManager } from '../integrations/ide-diagnostics';

describe('é˜¶æ®µ3 - é«˜çº§ç‰¹æ€§å’Œäº¤äº’æ¨¡å¼é›†æˆæµ‹è¯•', () => {
  let planModeManager: PlanModeManager;
  let steeringQueue: PlanAwareSteeringQueue;
  let specialModeHandler: SpecialModeHandler;
  let slashCommandManager: SlashCommandManager;
  let diagnosticsManager: IdeDiagnosticsManager;

  beforeEach(() => {
    // åˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶
    const mockEventLogger = jest.fn();
    planModeManager = new PlanModeManager('default', 'test-session', mockEventLogger);
    steeringQueue = new PlanAwareSteeringQueue(planModeManager);
    specialModeHandler = new SpecialModeHandler();
    slashCommandManager = new SlashCommandManager();
    diagnosticsManager = IdeDiagnosticsManager.getInstance();
  });

  afterEach(() => {
    // æ¸…ç†èµ„æº
    steeringQueue.stopStdinListening();
  });

  describe('Planæ¨¡å¼æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•', () => {
    test('wj2çŠ¶æ€æœºå¾ªç¯åŠŸèƒ½', () => {
      // æµ‹è¯•åŸºæœ¬å¾ªç¯ï¼šdefault â†’ acceptEdits â†’ plan â†’ default
      expect(wj2({ mode: 'default', isBypassPermissionsModeAvailable: false })).toBe('acceptEdits');
      expect(wj2({ mode: 'acceptEdits', isBypassPermissionsModeAvailable: false })).toBe('plan');
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: false })).toBe('default');
      
      // æµ‹è¯•å¸¦bypassæƒé™çš„å¾ªç¯
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: true })).toBe('bypassPermissions');
      expect(wj2({ mode: 'bypassPermissions', isBypassPermissionsModeAvailable: true })).toBe('default');
    });

    test('Planæ¨¡å¼ç®¡ç†å™¨çŠ¶æ€åˆ‡æ¢', () => {
      // æµ‹è¯•åˆå§‹çŠ¶æ€
      expect(planModeManager.getCurrentMode()).toBe('default');
      expect(planModeManager.isPlanMode()).toBe(false);

      // æµ‹è¯•æ¨¡å¼å¾ªç¯
      planModeManager.cyclePlanMode(false);
      expect(planModeManager.getCurrentMode()).toBe('acceptEdits');

      planModeManager.cyclePlanMode(false);
      expect(planModeManager.getCurrentMode()).toBe('plan');
      expect(planModeManager.isPlanMode()).toBe(true);

      planModeManager.cyclePlanMode(false);
      expect(planModeManager.getCurrentMode()).toBe('default');
    });

    test('Planæ¨¡å¼å¼ºåˆ¶è®¾ç½®', () => {
      planModeManager.setMode('plan', 'test_reason');
      expect(planModeManager.getCurrentMode()).toBe('plan');
      expect(planModeManager.isPlanMode()).toBe(true);
    });

    test('Planæ¨¡å¼ç›‘å¬å™¨æœºåˆ¶', () => {
      const mockListener = jest.fn();
      planModeManager.addListener('test-listener', mockListener);

      planModeManager.cyclePlanMode(false);
      expect(mockListener).toHaveBeenCalledWith(
        expect.objectContaining({
          currentMode: 'acceptEdits',
          previousMode: 'default'
        })
      );

      planModeManager.removeListener('test-listener');
      planModeManager.cyclePlanMode(false);
      expect(mockListener).toHaveBeenCalledTimes(1); // ä¸ä¼šå†æ¬¡è°ƒç”¨
    });
  });

  describe('å®æ—¶Steeringæœºåˆ¶æµ‹è¯•', () => {
    test('Steeringæ¶ˆæ¯é˜Ÿåˆ—åŸºæœ¬åŠŸèƒ½', async () => {
      const message = {
        type: 'user_input' as const,
        content: 'test message',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };

      steeringQueue.enqueue(message);
      const received = await steeringQueue.getSteeringMessage();
      expect(received).toEqual(message);
    });

    test('Planæ¨¡å¼ä¸‹çš„Steeringå¤„ç†', async () => {
      planModeManager.setMode('plan', 'test');
      
      const handler = new SteeringMessageHandler(planModeManager);
      const message = {
        type: 'user_input' as const,
        content: 'adjust the plan',
        timestamp: Date.now(),
        sessionId: 'test-session',
        planContext: { currentMode: 'plan' }
      };

      const result = await handler.handleMessage(message);
      expect(result.shouldContinue).toBe(true);
      expect(result.action).toBe('refine_plan');
    });

    test('Planæ‰¹å‡†å’Œæ‹’ç»å¤„ç†', async () => {
      planModeManager.setMode('plan', 'test');
      const handler = new SteeringMessageHandler(planModeManager);

      // æµ‹è¯•è®¡åˆ’æ‰¹å‡†
      const approvalMessage = {
        type: 'plan_approval' as const,
        content: 'approve plan',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };

      const approvalResult = await handler.handleMessage(approvalMessage);
      expect(approvalResult.action).toBe('execute_plan');
      expect(planModeManager.getCurrentMode()).toBe('default');

      // é‡ç½®åˆ°planæ¨¡å¼æµ‹è¯•æ‹’ç»
      planModeManager.setMode('plan', 'test');
      const rejectionMessage = {
        type: 'plan_rejection' as const,
        content: 'reject plan',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };

      const rejectionResult = await handler.handleMessage(rejectionMessage);
      expect(rejectionResult.shouldContinue).toBe(false);
      expect(rejectionResult.action).toBe('revise_plan');
    });
  });

  describe('ç‰¹æ®Šäº¤äº’æ¨¡å¼æµ‹è¯•', () => {
    test('Bashæ¨¡å¼æ£€æµ‹å’Œå¤„ç†', () => {
      const result = specialModeHandler.processInput('!ls -la');
      expect(result.mode).toBe('bash');
      expect(result.content).toBe('ls -la');
      expect(result.shouldExecute).toBe(true);
    });

    test('ç¬”è®°æ¨¡å¼æ£€æµ‹å’Œå¤„ç†', () => {
      const result = specialModeHandler.processInput('# è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ç¬”è®° #important');
      expect(result.mode).toBe('note');
      expect(result.shouldExecute).toBe(false);
      
      const notes = specialModeHandler.getNotes();
      expect(notes.length).toBe(1);
      expect(notes[0].content).toBe('è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•ç¬”è®° #important');
      expect(notes[0].tags).toContain('important');
    });

    test('å¤šè¡Œè¾“å…¥æ¨¡å¼', () => {
      // å¼€å§‹å¤šè¡Œè¾“å…¥
      let result = specialModeHandler.processInput('```javascript');
      expect(result.mode).toBe('multiline');
      expect(result.shouldExecute).toBe(false);

      // ç»§ç»­å¤šè¡Œè¾“å…¥
      result = specialModeHandler.processInput('function test() {');
      expect(result.mode).toBe('multiline');
      expect(result.shouldExecute).toBe(false);

      // ç»“æŸå¤šè¡Œè¾“å…¥
      result = specialModeHandler.processInput('```');
      expect(result.mode).toBe('normal');
      expect(result.shouldExecute).toBe(true);
      expect(result.content).toContain('function test() {');
    });

    test('æ¨¡å¼çŠ¶æ€æŸ¥è¯¢', () => {
      specialModeHandler.processInput('```');
      const status = specialModeHandler.getCurrentModeStatus();
      expect(status.mode).toBe('multiline');
      expect(status.isActive).toBe(true);
      expect(status.buffer).toHaveLength(1);
    });

    test('ç¬”è®°æœç´¢åŠŸèƒ½', () => {
      specialModeHandler.processInput('# ç¬¬ä¸€ä¸ªç¬”è®° #project #todo');
      specialModeHandler.processInput('# ç¬¬äºŒä¸ªç¬”è®° #meeting');
      specialModeHandler.processInput('# ç¬¬ä¸‰ä¸ªç¬”è®° #project #done');

      const projectNotes = specialModeHandler.searchNotes('project');
      expect(projectNotes).toHaveLength(2);

      const todoNotes = specialModeHandler.searchNotes('todo');
      expect(todoNotes).toHaveLength(1);
    });
  });

  describe('å¿«æ·æŒ‡ä»¤ç³»ç»Ÿæµ‹è¯•', () => {
    const mockContext = {
      sessionId: 'test-session',
      mcpServers: [],
      currentDirectory: '/test',
      planModeManager: planModeManager
    };

    test('å‘½ä»¤æ£€æµ‹å’Œè§£æ', () => {
      expect(slashCommandManager.isSlashCommand('/help')).toBe(true);
      expect(slashCommandManager.isSlashCommand('normal message')).toBe(false);
    });

    test('/helpå‘½ä»¤', async () => {
      const result = await slashCommandManager.execute('/help', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Available commands');
    });

    test('/helpå…·ä½“å‘½ä»¤', async () => {
      const result = await slashCommandManager.execute('/help login', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Command: /login');
    });

    test('/modeå‘½ä»¤', async () => {
      // æŸ¥è¯¢å½“å‰æ¨¡å¼
      let result = await slashCommandManager.execute('/mode', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Current mode: default');

      // åˆ‡æ¢æ¨¡å¼
      result = await slashCommandManager.execute('/mode plan', mockContext);
      expect(result.success).toBe(true);
      expect(planModeManager.getCurrentMode()).toBe('plan');
    });

    test('/statuså‘½ä»¤', async () => {
      const result = await slashCommandManager.execute('/status', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('System Status');
      expect(result.message).toContain('session: test-session');
    });

    test('/mcpå‘½ä»¤', async () => {
      const contextWithServers = {
        ...mockContext,
        mcpServers: [
          { name: 'test-server', status: 'connected', tools: ['tool1', 'tool2'] }
        ]
      };

      const result = await slashCommandManager.execute('/mcp list', contextWithServers);
      expect(result.success).toBe(true);
      expect(result.message).toContain('test-server: connected (2 tools)');
    });

    test('å‘½ä»¤è‡ªåŠ¨è¡¥å…¨', () => {
      const completions = slashCommandManager.getCompletions('/he');
      expect(completions).toContain('/help');

      const allCompletions = slashCommandManager.getCompletions('/');
      expect(allCompletions).toContain('/help');
      expect(allCompletions).toContain('/login');
      expect(allCompletions).toContain('/mode');
    });

    test('æ— æ•ˆå‘½ä»¤å¤„ç†', async () => {
      const result = await slashCommandManager.execute('/nonexistent', mockContext);
      expect(result.success).toBe(false);
      expect(result.message).toContain('Unknown command');
    });

    test('å‘½ä»¤åˆ«åæ”¯æŒ', async () => {
      const result = await slashCommandManager.execute('/cls', mockContext);
      expect(result.success).toBe(true);
      expect(result.message).toContain('Conversation history cleared');
    });
  });

  describe('IDEé›†æˆæµ‹è¯•', () => {
    test('è¯Šæ–­ç®¡ç†å™¨å•ä¾‹æ¨¡å¼', () => {
      const instance1 = IdeDiagnosticsManager.getInstance();
      const instance2 = IdeDiagnosticsManager.getInstance();
      expect(instance1).toBe(instance2);
    });

    test('è¯Šæ–­ä¿¡æ¯æ¯”è¾ƒ', () => {
      const manager = IdeDiagnosticsManager.getInstance();
      
      const diag1 = {
        message: 'Test error',
        severity: 1,
        source: 'eslint',
        code: 'E001',
        range: {
          start: { line: 10, character: 5 },
          end: { line: 10, character: 15 }
        }
      };

      const diag2 = { ...diag1 };
      const diag3 = { ...diag1, message: 'Different error' };

      expect(manager['areDiagnosticsEqual'](diag1, diag2)).toBe(true);
      expect(manager['areDiagnosticsEqual'](diag1, diag3)).toBe(false);
    });

    test('æ–‡ä»¶URIæ ‡å‡†åŒ–', () => {
      const manager = IdeDiagnosticsManager.getInstance();
      
      expect(manager['normalizeFileUri']('file:///path/to/file.js')).toBe('/path/to/file.js');
      expect(manager['normalizeFileUri']('_claude_fs_right:/path/to/file.js')).toBe('/path/to/file.js');
      expect(manager['normalizeFileUri']('/path/to/file.js')).toBe('/path/to/file.js');
    });

    test('è¯Šæ–­ç»Ÿè®¡è®¡ç®—', () => {
      const manager = IdeDiagnosticsManager.getInstance();
      
      // æ¨¡æ‹Ÿä¸€äº›è¯Šæ–­æ•°æ®
      manager['baseline'].set('/file1.js', [
        { message: 'Error 1', severity: 1, range: { start: { line: 0, character: 0 }, end: { line: 0, character: 5 } } },
        { message: 'Warning 1', severity: 2, range: { start: { line: 1, character: 0 }, end: { line: 1, character: 5 } } }
      ]);
      
      manager['baseline'].set('/file2.js', [
        { message: 'Info 1', severity: 3, range: { start: { line: 0, character: 0 }, end: { line: 0, character: 5 } } }
      ]);

      const stats = manager.getDiagnosticsStatistics();
      expect(stats.totalFiles).toBe(2);
      expect(stats.totalDiagnostics).toBe(3);
      expect(stats.errorCount).toBe(1);
      expect(stats.warningCount).toBe(1);
      expect(stats.infoCount).toBe(1);
    });
  });

  describe('ç»¼åˆé›†æˆæµ‹è¯•', () => {
    test('Planæ¨¡å¼ + Steeringæœºåˆ¶é›†æˆ', async () => {
      // è¿›å…¥Planæ¨¡å¼
      planModeManager.setMode('plan', 'integration_test');
      
      // å‘é€Steeringæ¶ˆæ¯
      const handler = new SteeringMessageHandler(planModeManager);
      const message = {
        type: 'user_input' as const,
        content: 'modify the plan to include testing',
        timestamp: Date.now(),
        sessionId: 'test-session',
        planContext: { currentMode: 'plan' }
      };

      const result = await handler.handleMessage(message);
      expect(result.action).toBe('refine_plan');
      expect(planModeManager.isPlanMode()).toBe(true);
    });

    test('ç‰¹æ®Šæ¨¡å¼ + å¿«æ·æŒ‡ä»¤é›†æˆ', async () => {
      // ç¬”è®°æ¨¡å¼åˆ›å»ºç¬”è®°
      specialModeHandler.processInput('# é›†æˆæµ‹è¯•ç¬”è®° #integration');
      
      // ä½¿ç”¨å¿«æ·æŒ‡ä»¤æŸ¥çœ‹çŠ¶æ€
      const context = {
        sessionId: 'test-session',
        mcpServers: [],
        currentDirectory: '/test',
        planModeManager: planModeManager
      };

      const result = await slashCommandManager.execute('/status', context);
      expect(result.success).toBe(true);

      // éªŒè¯ç¬”è®°å·²ä¿å­˜
      const notes = specialModeHandler.getNotes();
      expect(notes).toHaveLength(1);
      expect(notes[0].tags).toContain('integration');
    });

    test('å®Œæ•´å·¥ä½œæµç¨‹æ¨¡æ‹Ÿ', async () => {
      // 1. è¿›å…¥Planæ¨¡å¼
      planModeManager.setMode('plan', 'workflow_test');
      
      // 2. ä½¿ç”¨ç‰¹æ®Šæ¨¡å¼è®°å½•ç¬”è®°
      specialModeHandler.processInput('# è®¡åˆ’ï¼šå®ç°æ–°åŠŸèƒ½ #planning');
      
      // 3. ä½¿ç”¨å¿«æ·æŒ‡ä»¤æ£€æŸ¥çŠ¶æ€
      const context = {
        sessionId: 'test-session',
        mcpServers: [],
        currentDirectory: '/test',
        planModeManager: planModeManager
      };
      
      let result = await slashCommandManager.execute('/mode', context);
      expect(result.message).toContain('plan');
      
      // 4. é€šè¿‡Steeringæ‰¹å‡†è®¡åˆ’
      const handler = new SteeringMessageHandler(planModeManager);
      const approvalMessage = {
        type: 'plan_approval' as const,
        content: 'approve',
        timestamp: Date.now(),
        sessionId: 'test-session'
      };
      
      const approvalResult = await handler.handleMessage(approvalMessage);
      expect(approvalResult.action).toBe('execute_plan');
      expect(planModeManager.getCurrentMode()).toBe('default');
      
      // 5. éªŒè¯æœ€ç»ˆçŠ¶æ€
      result = await slashCommandManager.execute('/status', context);
      expect(result.message).toContain('default');
    });
  });
});
```

---

## ğŸ“‹ é˜¶æ®µ3å®ŒæˆéªŒè¯æ¸…å•

### åŠŸèƒ½éªŒè¯é¡¹ç›®

**Planæ¨¡å¼ç³»ç»Ÿ** âœ…
- [ ] wj2çŠ¶æ€æœºå¾ªç¯åŠŸèƒ½æ­£å¸¸
- [ ] Shift+Tabé”®åˆ‡æ¢å·¥ä½œæ­£å¸¸
- [ ] Planæ¨¡å¼UIæŒ‡ç¤ºå™¨æ˜¾ç¤ºæ­£ç¡®
- [ ] exit_plan_modeå·¥å…·æ­£å¸¸å·¥ä½œ
- [ ] ç³»ç»Ÿæé†’æ³¨å…¥æœºåˆ¶ç”Ÿæ•ˆ

**å®æ—¶Steeringæœºåˆ¶** âœ…
- [ ] h2Aæ¶ˆæ¯é˜Ÿåˆ—é›†æˆPlanæ¨¡å¼
- [ ] stdinç›‘å¬æ•è·ç”¨æˆ·è¾“å…¥
- [ ] Planæ¨¡å¼ä¸‹çš„ç‰¹æ®Šå‘½ä»¤å¤„ç†
- [ ] Steeringæ¶ˆæ¯ç±»å‹æ­£ç¡®åˆ†ç±»
- [ ] ç”¨æˆ·å¼•å¯¼å“åº”åŠæ—¶

**ç‰¹æ®Šäº¤äº’æ¨¡å¼** âœ…
- [ ] !bashæ¨¡å¼ç›´æ¥æ‰§è¡Œå‘½ä»¤
- [ ] #ç¬”è®°æ¨¡å¼è®°å½•å’Œæœç´¢
- [ ] å¤šè¡Œè¾“å…¥æ¨¡å¼æ­£å¸¸å·¥ä½œ
- [ ] æ¨¡å¼çŠ¶æ€æ­£ç¡®æ˜¾ç¤º
- [ ] æ¨¡å¼åˆ‡æ¢æµç•…

**å¿«æ·æŒ‡ä»¤ç³»ç»Ÿ** âœ…
- [ ] 15+æ–œæ å‘½ä»¤å…¨éƒ¨å®ç°
- [ ] å‘½ä»¤è‡ªåŠ¨è¡¥å…¨åŠŸèƒ½
- [ ] å‚æ•°è§£æå’ŒéªŒè¯
- [ ] é”™è¯¯å¤„ç†å’Œå¸®åŠ©ä¿¡æ¯
- [ ] å‘½ä»¤åˆ«åæ”¯æŒ

**IDEé›†æˆæœºåˆ¶** âœ…
- [ ] PKè¯Šæ–­ç®¡ç†å™¨æ­£å¸¸å·¥ä½œ
- [ ] LSPåè®®é›†æˆæˆåŠŸ
- [ ] è¯Šæ–­ä¿¡æ¯æ¯”è¾ƒç®—æ³•å‡†ç¡®
- [ ] MCPå·¥å…·ç™½åå•æœºåˆ¶
- [ ] IDEè¿æ¥æ£€æµ‹åŠŸèƒ½

### æ€§èƒ½éªŒè¯é¡¹ç›®

**å“åº”æ€§èƒ½** âœ…
- [ ] æ¨¡å¼åˆ‡æ¢å“åº” < 100ms
- [ ] Steeringæ¶ˆæ¯å¤„ç† < 200ms
- [ ] å¿«æ·æŒ‡ä»¤æ‰§è¡Œ < 500ms
- [ ] è¯Šæ–­ä¿¡æ¯è·å– < 1s
- [ ] UIæ›´æ–°æµç•…æ— å¡é¡¿

**å†…å­˜ä½¿ç”¨** âœ…
- [ ] Planæ¨¡å¼çŠ¶æ€å ç”¨ < 10MB
- [ ] Steeringé˜Ÿåˆ—ç¼“å†² < 50MB
- [ ] è¯Šæ–­ä¿¡æ¯ç¼“å­˜ < 100MB
- [ ] æ€»ä½“å†…å­˜å¢é•¿ < 200MB

**å¹¶å‘å¤„ç†** âœ…
- [ ] å¤šæ¨¡å¼åŒæ—¶è¿è¡Œç¨³å®š
- [ ] Steeringæ¶ˆæ¯ä¸ä¸¢å¤±
- [ ] å¿«æ·æŒ‡ä»¤ä¸å†²çª
- [ ] IDEé›†æˆä¸é˜»å¡ä¸»æµç¨‹

### è´¨é‡éªŒè¯é¡¹ç›®

**ä»£ç è´¨é‡** âœ…
- [ ] TypeScriptç±»å‹è¦†ç›– > 95%
- [ ] å•å…ƒæµ‹è¯•è¦†ç›– > 80%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡ç‡ 100%
- [ ] ä»£ç å¤æ‚åº¦ < 10
- [ ] æ— ESLintè­¦å‘Šé”™è¯¯

**ç”¨æˆ·ä½“éªŒ** âœ…
- [ ] æ“ä½œç›´è§‚æ˜“æ‡‚
- [ ] é”™è¯¯æç¤ºå‹å¥½
- [ ] åŠŸèƒ½å‘ç°æ€§å¥½
- [ ] å¸®åŠ©æ–‡æ¡£å®Œæ•´
- [ ] é”®ç›˜å¿«æ·é”®é«˜æ•ˆ

**å…¼å®¹æ€§** âœ…
- [ ] Node.js 18+ æ”¯æŒ
- [ ] ä¸»æµIDEå…¼å®¹
- [ ] å¤šæ“ä½œç³»ç»Ÿæ”¯æŒ
- [ ] ç»ˆç«¯ç¯å¢ƒé€‚é…
- [ ] MCPåè®®æ ‡å‡†åˆè§„

---

## ğŸ¯ ä¸‹ä¸€é˜¶æ®µé¢„å‘Š

é˜¶æ®µ3å®Œæˆåï¼ŒOpen Claude Codeå°†å…·å¤‡ï¼š

1. **å®Œæ•´çš„é«˜çº§äº¤äº’èƒ½åŠ›**ï¼š
   - Planæ¨¡å¼å®‰å…¨åˆ†æ
   - å®æ—¶ç”¨æˆ·å¼•å¯¼
   - ç‰¹æ®Šæ¨¡å¼å¤„ç†
   - å¿«æ·æŒ‡ä»¤ç³»ç»Ÿ

2. **IDEæ·±åº¦é›†æˆèƒ½åŠ›**ï¼š
   - LSPè¯Šæ–­ä¿¡æ¯
   - ä»£ç æ‰§è¡Œç¯å¢ƒ
   - å®æ—¶çŠ¶æ€åŒæ­¥
   - MCPåè®®æ”¯æŒ

3. **ä¼˜ç§€çš„ç”¨æˆ·ä½“éªŒ**ï¼š
   - ç›´è§‚çš„UIæŒ‡ç¤º
   - æµç•…çš„äº¤äº’å“åº”
   - å®Œå–„çš„å¸®åŠ©ç³»ç»Ÿ
   - é«˜æ•ˆçš„å¿«æ·æ“ä½œ

**è¿›å…¥é˜¶æ®µ4**ï¼šMCPé›†æˆå’Œæ‰©å±•ç³»ç»Ÿï¼ˆ4å‘¨ï¼‰
- å®Œæ•´MCPåè®®å®ç°
- å¤šä¼ è¾“æ–¹å¼æ”¯æŒ
- æ’ä»¶ç”Ÿæ€ç³»ç»Ÿ
- ç¬¬ä¸‰æ–¹å·¥å…·é›†æˆ

è¿™æ ‡å¿—ç€Open Claude Codeåœ¨é«˜çº§ç‰¹æ€§å®ç°ä¸Šçš„é‡å¤§çªç ´ï¼Œä¸ºåç»­çš„MCPé›†æˆå’Œæ‰©å±•å¥ å®šäº†åšå®åŸºç¡€ã€‚