# é˜¶æ®µ5ï¼šæµ‹è¯•ä¼˜åŒ–å’Œå‘å¸ƒå‡†å¤‡æ–½å·¥æŒ‡å—

## ğŸ“‹ é¢å‘å¯¹è±¡
**æœ¬æ–‡æ¡£é¢å‘ï¼šèœé¸Ÿçº§åˆ«çš„åˆçº§ç¨‹åºå‘˜**
- æ— éœ€æ·±åº¦æ€è€ƒï¼Œä¸¥æ ¼æŒ‰æ­¥éª¤æ‰§è¡Œ
- æ¯ä¸ªæ­¥éª¤éƒ½æœ‰æ˜ç¡®çš„æ–‡ä»¶æ“ä½œæŒ‡ä»¤
- åŒ…å«å¿…è¦çš„ä»£ç æ¨¡æ¿å’Œé…ç½®

## ğŸ¯ é˜¶æ®µç›®æ ‡
åŸºäºå‰4ä¸ªé˜¶æ®µçš„å®Œæ•´å®ç°ï¼Œè¿›è¡Œç³»ç»Ÿä¼˜åŒ–å’Œå‘å¸ƒå‡†å¤‡ï¼š
- âœ… **æ€§èƒ½ä¼˜åŒ–å’ŒåŸºå‡†æµ‹è¯•** (å†…å­˜ã€CPUã€ç½‘ç»œã€å“åº”æ—¶é—´ä¼˜åŒ–)
- âœ… **å®Œæ•´æµ‹è¯•è¦†ç›–** (å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•)
- âœ… **æ–‡æ¡£å’Œç”¨æˆ·æŒ‡å—** (APIæ–‡æ¡£ã€ç”¨æˆ·æ‰‹å†Œã€å¼€å‘æŒ‡å—ã€æ•…éšœæ’é™¤)
- âœ… **CI/CDå’Œå‘å¸ƒæµç¨‹** (è‡ªåŠ¨åŒ–æ„å»ºã€æµ‹è¯•ã€éƒ¨ç½²ã€ç‰ˆæœ¬ç®¡ç†)
- âœ… **ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–** (ç›‘æ§ã€æ—¥å¿—ã€é”™è¯¯å¤„ç†ã€å®‰å…¨åŠ å›º)

**é¢„æœŸäº¤ä»˜æˆæœ**ï¼š
- âœ… å®Œæ•´çš„æµ‹è¯•å¥—ä»¶ (è¦†ç›–ç‡ > 90%)
- âœ… æ€§èƒ½åŸºå‡†å’Œä¼˜åŒ–æŠ¥å‘Š
- âœ… å®Œæ•´çš„ç”¨æˆ·å’Œå¼€å‘æ–‡æ¡£
- âœ… ç”Ÿäº§å°±ç»ªçš„å‘å¸ƒç‰ˆæœ¬
- âœ… CI/CDè‡ªåŠ¨åŒ–æµç¨‹

**å·¥ä½œæ—¶é—´**ï¼š2å‘¨ (80å·¥æ—¶)

---

## ğŸ“ ç¬¬ä¸€å‘¨ï¼šæ€§èƒ½ä¼˜åŒ–å’Œæµ‹è¯•å®Œå–„

### æ­¥éª¤5.1: æ€§èƒ½åŸºå‡†æµ‹è¯•æ¡†æ¶

**å»ºç«‹å®Œæ•´çš„æ€§èƒ½æµ‹è¯•å’Œç›‘æ§ä½“ç³»**

**æ–‡ä»¶è·¯å¾„**: `src/__tests__/performance/benchmark-suite.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * Open Claude Code æ€§èƒ½åŸºå‡†æµ‹è¯•å¥—ä»¶
 * æµ‹è¯•ç³»ç»Ÿå„ç»„ä»¶çš„æ€§èƒ½è¡¨ç°å’Œèµ„æºä½¿ç”¨
 */

import { performance } from 'perf_hooks';
import * as os from 'os';
import * as process from 'process';

export interface PerformanceMetrics {
  cpu: {
    usage: number;
    loadAverage: number[];
  };
  memory: {
    used: number;
    total: number;
    heapUsed: number;
    heapTotal: number;
    external: number;
  };
  timing: {
    responseTime: number;
    throughput: number;
    latency: number;
  };
  network: {
    connectionTime: number;
    dataTransfer: number;
  };
}

export interface BenchmarkResult {
  name: string;
  metrics: PerformanceMetrics;
  passed: boolean;
  baseline: PerformanceMetrics;
  improvement: number; // ç™¾åˆ†æ¯”æ”¹è¿›
  timestamp: number;
}

/**
 * æ€§èƒ½ç›‘æ§å™¨
 */
export class PerformanceMonitor {
  private startTime: number = 0;
  private startMemory: NodeJS.MemoryUsage;
  private measurements: PerformanceMetrics[] = [];

  constructor() {
    this.startMemory = process.memoryUsage();
  }

  /**
   * å¼€å§‹æ€§èƒ½ç›‘æ§
   */
  public start(): void {
    this.startTime = performance.now();
    this.startMemory = process.memoryUsage();
  }

  /**
   * ç»“æŸç›‘æ§å¹¶è·å–æŒ‡æ ‡
   */
  public end(): PerformanceMetrics {
    const endTime = performance.now();
    const endMemory = process.memoryUsage();
    const cpuUsage = process.cpuUsage();

    const metrics: PerformanceMetrics = {
      cpu: {
        usage: (cpuUsage.user + cpuUsage.system) / 1000, // è½¬æ¢ä¸ºæ¯«ç§’
        loadAverage: os.loadavg()
      },
      memory: {
        used: endMemory.rss - this.startMemory.rss,
        total: os.totalmem(),
        heapUsed: endMemory.heapUsed,
        heapTotal: endMemory.heapTotal,
        external: endMemory.external
      },
      timing: {
        responseTime: endTime - this.startTime,
        throughput: 0, // å°†ç”±å…·ä½“æµ‹è¯•è®¡ç®—
        latency: endTime - this.startTime
      },
      network: {
        connectionTime: 0, // å°†ç”±ç½‘ç»œæµ‹è¯•å¡«å……
        dataTransfer: 0
      }
    };

    this.measurements.push(metrics);
    return metrics;
  }

  /**
   * è·å–å¹³å‡æŒ‡æ ‡
   */
  public getAverageMetrics(): PerformanceMetrics {
    if (this.measurements.length === 0) {
      throw new Error('No measurements available');
    }

    const avg = this.measurements.reduce((acc, metrics) => {
      acc.cpu.usage += metrics.cpu.usage;
      acc.memory.used += metrics.memory.used;
      acc.timing.responseTime += metrics.timing.responseTime;
      acc.timing.throughput += metrics.timing.throughput;
      acc.timing.latency += metrics.timing.latency;
      acc.network.connectionTime += metrics.network.connectionTime;
      acc.network.dataTransfer += metrics.network.dataTransfer;
      return acc;
    }, {
      cpu: { usage: 0, loadAverage: os.loadavg() },
      memory: { used: 0, total: os.totalmem(), heapUsed: 0, heapTotal: 0, external: 0 },
      timing: { responseTime: 0, throughput: 0, latency: 0 },
      network: { connectionTime: 0, dataTransfer: 0 }
    });

    const count = this.measurements.length;
    return {
      cpu: {
        usage: avg.cpu.usage / count,
        loadAverage: avg.cpu.loadAverage
      },
      memory: {
        used: avg.memory.used / count,
        total: avg.memory.total,
        heapUsed: avg.memory.heapUsed / count,
        heapTotal: avg.memory.heapTotal / count,
        external: avg.memory.external / count
      },
      timing: {
        responseTime: avg.timing.responseTime / count,
        throughput: avg.timing.throughput / count,
        latency: avg.timing.latency / count
      },
      network: {
        connectionTime: avg.network.connectionTime / count,
        dataTransfer: avg.network.dataTransfer / count
      }
    };
  }
}

/**
 * åŸºå‡†æµ‹è¯•å¥—ä»¶
 */
export class BenchmarkSuite {
  private baselines: Map<string, PerformanceMetrics> = new Map();
  private results: BenchmarkResult[] = [];

  /**
   * è®¾ç½®åŸºå‡†çº¿
   */
  public setBaseline(name: string, metrics: PerformanceMetrics): void {
    this.baselines.set(name, metrics);
  }

  /**
   * è¿è¡ŒåŸºå‡†æµ‹è¯•
   */
  public async runBenchmark(
    name: string,
    testFunction: () => Promise<void>,
    iterations: number = 10
  ): Promise<BenchmarkResult> {
    const monitor = new PerformanceMonitor();
    
    // é¢„çƒ­
    await testFunction();
    
    // æ‰§è¡Œæµ‹è¯•
    for (let i = 0; i < iterations; i++) {
      monitor.start();
      await testFunction();
      monitor.end();
    }

    const metrics = monitor.getAverageMetrics();
    const baseline = this.baselines.get(name);
    
    let improvement = 0;
    let passed = true;

    if (baseline) {
      improvement = ((baseline.timing.responseTime - metrics.timing.responseTime) / baseline.timing.responseTime) * 100;
      passed = metrics.timing.responseTime <= baseline.timing.responseTime * 1.1; // å…è®¸10%çš„æ€§èƒ½ä¸‹é™
    }

    const result: BenchmarkResult = {
      name,
      metrics,
      passed,
      baseline: baseline || metrics,
      improvement,
      timestamp: Date.now()
    };

    this.results.push(result);
    return result;
  }

  /**
   * Agentæ ¸å¿ƒæ€§èƒ½æµ‹è¯•
   */
  public async benchmarkAgentCore(): Promise<BenchmarkResult> {
    const { AgentCore } = await import('../../core/agent-core');
    const { h2A } = await import('../../core/message-queue');
    
    return this.runBenchmark('agent-core', async () => {
      const steeringQueue = new h2A();
      const agentCore = new AgentCore(steeringQueue);
      
      // æ¨¡æ‹Ÿå…¸å‹çš„Agentä»»åŠ¡
      const messages = [
        { role: 'user', content: 'Hello, please help me with a simple task' }
      ];
      
      const config = {
        model: 'claude-3-sonnet',
        maxTokens: 1000,
        timeout: 5000
      };
      
      // æ¨¡æ‹ŸAgentå¾ªç¯æ‰§è¡Œ
      const generator = agentCore.mainLoop(messages, config, {});
      const results = [];
      
      for await (const chunk of generator) {
        results.push(chunk);
        if (results.length > 5) break; // é™åˆ¶æµ‹è¯•è§„æ¨¡
      }
    });
  }

  /**
   * å·¥å…·æ‰§è¡Œæ€§èƒ½æµ‹è¯•
   */
  public async benchmarkToolExecution(): Promise<BenchmarkResult> {
    const { ToolRegistry } = await import('../../tools/registry');
    
    return this.runBenchmark('tool-execution', async () => {
      const registry = new ToolRegistry();
      
      // æµ‹è¯•å¤šä¸ªå·¥å…·è°ƒç”¨
      await registry.executeTool('Read', { file_path: '/tmp/test.txt' });
      await registry.executeTool('LS', { path: '/tmp' });
      await registry.executeTool('Grep', { pattern: 'test', path: '/tmp' });
    });
  }

  /**
   * MCPè¿æ¥æ€§èƒ½æµ‹è¯•
   */
  public async benchmarkMcpConnections(): Promise<BenchmarkResult> {
    const { McpServerManager } = await import('../../mcp/server-manager');
    
    return this.runBenchmark('mcp-connections', async () => {
      const manager = new McpServerManager();
      
      // æ¨¡æ‹Ÿå¤šä¸ªæœåŠ¡å™¨è¿æ¥
      const servers = Array.from({ length: 5 }, (_, i) => ({
        name: `test-server-${i}`,
        transport: { type: 'stdio' as const, command: 'echo' }
      }));
      
      await Promise.all(servers.map(config => manager.addServer(config)));
      
      // æ¨¡æ‹Ÿå·¥å…·è°ƒç”¨
      for (let i = 0; i < 10; i++) {
        try {
          await manager.callTool('echo', { message: `test-${i}` });
        } catch (error) {
          // å¿½ç•¥æµ‹è¯•ä¸­çš„è¿æ¥é”™è¯¯
        }
      }
      
      await manager.cleanup();
    });
  }

  /**
   * Planæ¨¡å¼æ€§èƒ½æµ‹è¯•
   */
  public async benchmarkPlanMode(): Promise<BenchmarkResult> {
    const { PlanModeManager } = await import('../../core/plan-mode');
    const { PlanAwareSteeringQueue } = await import('../../core/steering-plan-integration');
    
    return this.runBenchmark('plan-mode', async () => {
      const eventLogger = () => {};
      const planManager = new PlanModeManager('default', 'test-session', eventLogger);
      const steeringQueue = new PlanAwareSteeringQueue(planManager);
      
      // æ¨¡æ‹ŸPlanæ¨¡å¼æ“ä½œ
      for (let i = 0; i < 20; i++) {
        planManager.cyclePlanMode();
        
        if (planManager.isPlanMode()) {
          // æ¨¡æ‹ŸPlanæ¨¡å¼ä¸‹çš„æ“ä½œ
          steeringQueue.enqueue({
            type: 'user_input',
            content: `plan input ${i}`,
            timestamp: Date.now(),
            sessionId: 'test'
          });
        }
      }
    });
  }

  /**
   * UIæ¸²æŸ“æ€§èƒ½æµ‹è¯•
   */
  public async benchmarkUIRendering(): Promise<BenchmarkResult> {
    return this.runBenchmark('ui-rendering', async () => {
      // æ¨¡æ‹Ÿå¤§é‡UIç»„ä»¶æ¸²æŸ“
      const React = await import('react');
      const { render } = await import('react-dom/server');
      
      const TestComponent = React.createElement('div', null,
        Array.from({ length: 100 }, (_, i) =>
          React.createElement('span', { key: i }, `Item ${i}`)
        )
      );
      
      // æ¸²æŸ“100æ¬¡
      for (let i = 0; i < 100; i++) {
        render(TestComponent);
      }
    });
  }

  /**
   * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
   */
  public generateReport(): string {
    const report = ['# Open Claude Code æ€§èƒ½åŸºå‡†æµ‹è¯•æŠ¥å‘Š\n'];
    
    report.push(`## æµ‹è¯•æ¦‚è§ˆ`);
    report.push(`- æ€»æµ‹è¯•æ•°: ${this.results.length}`);
    report.push(`- é€šè¿‡æµ‹è¯•: ${this.results.filter(r => r.passed).length}`);
    report.push(`- å¤±è´¥æµ‹è¯•: ${this.results.filter(r => !r.passed).length}`);
    report.push(`- æµ‹è¯•æ—¶é—´: ${new Date().toISOString()}\n`);
    
    report.push(`## è¯¦ç»†ç»“æœ\n`);
    
    for (const result of this.results) {
      report.push(`### ${result.name}`);
      report.push(`- **çŠ¶æ€**: ${result.passed ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}`);
      report.push(`- **å“åº”æ—¶é—´**: ${result.metrics.timing.responseTime.toFixed(2)}ms`);
      report.push(`- **å†…å­˜ä½¿ç”¨**: ${(result.metrics.memory.used / 1024 / 1024).toFixed(2)}MB`);
      report.push(`- **CPUä½¿ç”¨**: ${result.metrics.cpu.usage.toFixed(2)}ms`);
      
      if (result.baseline) {
        report.push(`- **æ€§èƒ½æ”¹è¿›**: ${result.improvement.toFixed(2)}%`);
      }
      
      report.push('');
    }
    
    report.push(`## æ€§èƒ½åŸºå‡†çº¿\n`);
    report.push(`| æµ‹è¯•é¡¹ | å“åº”æ—¶é—´ | å†…å­˜ä½¿ç”¨ | CPUä½¿ç”¨ | çŠ¶æ€ |`);
    report.push(`|-------|---------|---------|---------|------|`);
    
    for (const result of this.results) {
      const status = result.passed ? 'âœ…' : 'âŒ';
      report.push(`| ${result.name} | ${result.metrics.timing.responseTime.toFixed(2)}ms | ${(result.metrics.memory.used / 1024 / 1024).toFixed(2)}MB | ${result.metrics.cpu.usage.toFixed(2)}ms | ${status} |`);
    }
    
    return report.join('\n');
  }

  /**
   * è¿è¡Œå®Œæ•´åŸºå‡†æµ‹è¯•å¥—ä»¶
   */
  public async runFullSuite(): Promise<BenchmarkResult[]> {
    console.log('å¼€å§‹è¿è¡Œå®Œæ•´æ€§èƒ½åŸºå‡†æµ‹è¯•å¥—ä»¶...');
    
    const tests = [
      () => this.benchmarkAgentCore(),
      () => this.benchmarkToolExecution(),
      () => this.benchmarkMcpConnections(),
      () => this.benchmarkPlanMode(),
      () => this.benchmarkUIRendering()
    ];
    
    const results = [];
    for (const test of tests) {
      try {
        const result = await test();
        results.push(result);
        console.log(`âœ… ${result.name}: ${result.metrics.timing.responseTime.toFixed(2)}ms`);
      } catch (error) {
        console.error(`âŒ æµ‹è¯•å¤±è´¥:`, error);
      }
    }
    
    console.log('\næ€§èƒ½åŸºå‡†æµ‹è¯•å®Œæˆï¼');
    console.log(this.generateReport());
    
    return results;
  }
}
```

### æ­¥éª¤5.2: å®Œæ•´æµ‹è¯•è¦†ç›–ç‡

**å»ºç«‹å…¨é¢çš„æµ‹è¯•ä½“ç³»ç¡®ä¿ä»£ç è´¨é‡**

**æ–‡ä»¶è·¯å¾„**: `src/__tests__/coverage/test-suite.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * Open Claude Code å®Œæ•´æµ‹è¯•å¥—ä»¶
 * ç¡®ä¿90%+çš„ä»£ç è¦†ç›–ç‡å’Œå…¨é¢çš„åŠŸèƒ½éªŒè¯
 */

import { describe, test, expect, beforeEach, afterEach, jest } from '@jest/testing-library';

/**
 * æµ‹è¯•è¦†ç›–ç‡é…ç½®
 */
export const coverageConfig = {
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.test.ts',
    '!src/**/__tests__/**',
    '!src/**/node_modules/**'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html', 'json'],
  coverageThreshold: {
    global: {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    }
  }
};

/**
 * æµ‹è¯•å·¥å…·ç±»
 */
export class TestUtils {
  /**
   * åˆ›å»ºæ¨¡æ‹Ÿçš„Agenté…ç½®
   */
  static createMockAgentConfig() {
    return {
      model: 'claude-3-sonnet',
      maxTokens: 1000,
      temperature: 0.7,
      timeout: 30000,
      fallbackModel: 'claude-3-haiku'
    };
  }

  /**
   * åˆ›å»ºæ¨¡æ‹Ÿçš„æ¶ˆæ¯é˜Ÿåˆ—
   */
  static createMockMessageQueue() {
    const { h2A } = require('../../core/message-queue');
    return new h2A();
  }

  /**
   * åˆ›å»ºæ¨¡æ‹Ÿçš„å·¥å…·ä¸Šä¸‹æ–‡
   */
  static createMockToolContext() {
    return {
      sessionId: 'test-session',
      userId: 'test-user',
      agentId: 'test-agent',
      workingDirectory: '/tmp/test',
      permissions: ['read', 'write'],
      timeout: 30000
    };
  }

  /**
   * åˆ›å»ºæ¨¡æ‹Ÿçš„MCPæœåŠ¡å™¨é…ç½®
   */
  static createMockMcpServerConfig() {
    return {
      name: 'test-server',
      transport: {
        type: 'stdio' as const,
        command: 'echo',
        args: ['test']
      },
      timeout: 5000,
      retryAttempts: 3
    };
  }

  /**
   * ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆ
   */
  static async waitFor(condition: () => boolean, timeout: number = 5000): Promise<void> {
    const start = Date.now();
    while (!condition() && Date.now() - start < timeout) {
      await new Promise(resolve => setTimeout(resolve, 10));
    }
    if (!condition()) {
      throw new Error('Condition not met within timeout');
    }
  }

  /**
   * æ¨¡æ‹Ÿæ–‡ä»¶ç³»ç»Ÿæ“ä½œ
   */
  static mockFileSystem() {
    const fs = require('fs/promises');
    const mockFs = {
      readFile: jest.fn(),
      writeFile: jest.fn(),
      readdir: jest.fn(),
      stat: jest.fn(),
      access: jest.fn(),
      mkdir: jest.fn()
    };
    
    Object.assign(fs, mockFs);
    return mockFs;
  }

  /**
   * æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
   */
  static mockNetworkRequests() {
    const mockFetch = jest.fn();
    global.fetch = mockFetch;
    return mockFetch;
  }

  /**
   * åˆ›å»ºæ€§èƒ½æµ‹è¯•è¾…åŠ©å‡½æ•°
   */
  static measurePerformance<T>(fn: () => Promise<T>): Promise<{ result: T; duration: number }> {
    return new Promise(async (resolve) => {
      const start = performance.now();
      const result = await fn();
      const duration = performance.now() - start;
      resolve({ result, duration });
    });
  }
}

/**
 * æ ¸å¿ƒç»„ä»¶æµ‹è¯•å¥—ä»¶
 */
describe('Core Components Test Suite', () => {
  describe('Agent Core Engine', () => {
    test('ä¸»å¾ªç¯åŸºæœ¬åŠŸèƒ½', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const steeringQueue = TestUtils.createMockMessageQueue();
      const agent = new AgentCore(steeringQueue);
      
      const messages = [{ role: 'user', content: 'Hello' }];
      const config = TestUtils.createMockAgentConfig();
      
      // æµ‹è¯•Agentä¸»å¾ªç¯
      const generator = agent.mainLoop(messages, config, {});
      const firstChunk = await generator.next();
      
      expect(firstChunk).toBeDefined();
    });

    test('æ¶ˆæ¯å‹ç¼©æœºåˆ¶', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const agent = new AgentCore(TestUtils.createMockMessageQueue());
      
      // åˆ›å»ºå¤§é‡æ¶ˆæ¯æµ‹è¯•å‹ç¼©
      const messages = Array.from({ length: 100 }, (_, i) => ({
        role: 'user',
        content: `Message ${i}`
      }));
      
      const compressed = await agent.compressMessages(messages, { maxMessages: 10 });
      expect(compressed.messages.length).toBeLessThanOrEqual(10);
      expect(compressed.wasCompacted).toBe(true);
    });

    test('é”™è¯¯å¤„ç†å’Œæ¢å¤', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const agent = new AgentCore(TestUtils.createMockMessageQueue());
      
      // æ¨¡æ‹ŸAPIé”™è¯¯
      const mockGenerator = async function* () {
        throw new Error('API Error');
      };
      
      agent.streamGenerator = mockGenerator;
      
      const messages = [{ role: 'user', content: 'Test' }];
      const config = { ...TestUtils.createMockAgentConfig(), fallbackModel: 'claude-3-haiku' };
      
      // åº”è¯¥èƒ½å¤Ÿå¤„ç†é”™è¯¯å¹¶ä½¿ç”¨å›é€€æ¨¡å‹
      await expect(async () => {
        const generator = agent.mainLoop(messages, config, {});
        await generator.next();
      }).not.toThrow();
    });

    test('å®æ—¶Steeringæœºåˆ¶', async () => {
      const { AgentCore } = await import('../../core/agent-core');
      const { PlanAwareSteeringQueue } = await import('../../core/steering-plan-integration');
      const { PlanModeManager } = await import('../../core/plan-mode');
      
      const planManager = new PlanModeManager('default', 'test', () => {});
      const steeringQueue = new PlanAwareSteeringQueue(planManager);
      const agent = new AgentCore(steeringQueue);
      
      // æ¨¡æ‹Ÿå®æ—¶ç”¨æˆ·è¾“å…¥
      steeringQueue.enqueue({
        type: 'user_input',
        content: 'interrupt message',
        timestamp: Date.now(),
        sessionId: 'test'
      });
      
      const steeringMessage = await agent.checkSteeringInput();
      expect(steeringMessage).toBeDefined();
    });
  });

  describe('Message Queue System', () => {
    test('h2Aå¼‚æ­¥é˜Ÿåˆ—åŸºæœ¬åŠŸèƒ½', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      const message = { test: 'data' };
      queue.enqueue(message);
      
      const iterator = queue[Symbol.asyncIterator]();
      const result = await iterator.next();
      
      expect(result.value).toEqual(message);
      expect(result.done).toBe(false);
    });

    test('é˜Ÿåˆ—å®Œæˆå’Œæ¸…ç†', async () => {
      const { h2A } = await import('../../core/message-queue');
      let cleanupCalled = false;
      const queue = new h2A(() => { cleanupCalled = true; });
      
      queue.complete();
      
      const iterator = queue[Symbol.asyncIterator]();
      const result = await iterator.next();
      
      expect(result.done).toBe(true);
      expect(cleanupCalled).toBe(true);
    });

    test('é”™è¯¯å¤„ç†', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      const error = new Error('Test error');
      queue.error(error);
      
      const iterator = queue[Symbol.asyncIterator]();
      
      await expect(iterator.next()).rejects.toThrow('Test error');
    });

    test('å¹¶å‘è®¿é—®å®‰å…¨æ€§', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      // å¤šä¸ªæ¶ˆè´¹è€…åŒæ—¶è¯»å–
      const consumers = Array.from({ length: 5 }, async (_, i) => {
        const iterator = queue[Symbol.asyncIterator]();
        return iterator.next();
      });
      
      // ç”Ÿäº§è€…æ·»åŠ æ¶ˆæ¯
      for (let i = 0; i < 5; i++) {
        queue.enqueue({ id: i });
      }
      
      const results = await Promise.all(consumers);
      expect(results.every(r => !r.done)).toBe(true);
    });
  });

  describe('Tool System', () => {
    test('å·¥å…·æ³¨å†Œå’Œå‘ç°', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      const tools = registry.getAllTools();
      expect(tools.length).toBeGreaterThan(0);
      
      const readTool = registry.getTool('Read');
      expect(readTool).toBeDefined();
      expect(readTool.name).toBe('Read');
    });

    test('å·¥å…·æ‰§è¡Œå’Œç»“æœå¤„ç†', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      // æ¨¡æ‹Ÿæ–‡ä»¶ç³»ç»Ÿ
      const mockFs = TestUtils.mockFileSystem();
      mockFs.readFile.mockResolvedValue('test content');
      
      const context = TestUtils.createMockToolContext();
      const result = await registry.executeTool('Read', { file_path: '/test.txt' }, context);
      
      expect(result).toBeDefined();
      expect(mockFs.readFile).toHaveBeenCalledWith('/test.txt', 'utf-8');
    });

    test('å·¥å…·æƒé™éªŒè¯', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      const context = { ...TestUtils.createMockToolContext(), permissions: ['read'] };
      
      // åº”è¯¥å…è®¸è¯»å–æ“ä½œ
      await expect(registry.executeTool('Read', { file_path: '/test.txt' }, context))
        .resolves.toBeDefined();
      
      // åº”è¯¥æ‹’ç»å†™å…¥æ“ä½œ
      await expect(registry.executeTool('Write', { file_path: '/test.txt', content: 'test' }, context))
        .rejects.toThrow();
    });

    test('å·¥å…·å¹¶å‘æ‰§è¡Œ', async () => {
      const { ToolRegistry } = await import('../../tools/registry');
      const registry = new ToolRegistry();
      
      const mockFs = TestUtils.mockFileSystem();
      mockFs.readFile.mockResolvedValue('content');
      
      // å¹¶å‘æ‰§è¡Œå¤šä¸ªå·¥å…·
      const context = TestUtils.createMockToolContext();
      const promises = Array.from({ length: 10 }, (_, i) =>
        registry.executeTool('Read', { file_path: `/test${i}.txt` }, context)
      );
      
      const results = await Promise.all(promises);
      expect(results).toHaveLength(10);
    });

    test('Editå·¥å…·å¼ºåˆ¶è¯»å–æœºåˆ¶', async () => {
      const { EditTool } = await import('../../tools/implementations/edit');
      const tool = new EditTool();
      
      const context = TestUtils.createMockToolContext();
      
      // æœªè¯»å–æ–‡ä»¶æ—¶åº”è¯¥å¤±è´¥
      await expect(tool.call({
        file_path: '/unread.txt',
        old_string: 'old',
        new_string: 'new'
      }, context)).rejects.toThrow();
      
      // è¯»å–æ–‡ä»¶ååº”è¯¥æˆåŠŸ
      await tool.beforeEdit('/unread.txt', context);
      await expect(tool.call({
        file_path: '/unread.txt',
        old_string: 'old',
        new_string: 'new'
      }, context)).resolves.toBeDefined();
    });

    test('Taskå·¥å…·å¤šAgentæ¶æ„', async () => {
      const { TaskTool } = await import('../../tools/implementations/task');
      const tool = new TaskTool();
      
      const context = TestUtils.createMockToolContext();
      
      const result = await tool.call({
        task_description: 'Test parallel task',
        task_prompt: 'Execute multiple subtasks',
        context: { parallel: true }
      }, context);
      
      expect(result).toBeDefined();
      // éªŒè¯SubAgentå®ä¾‹åŒ–å’Œå¹¶å‘æ‰§è¡Œ
    });
  });

  describe('Plan Mode System', () => {
    test('æ¨¡å¼å¾ªç¯çŠ¶æ€æœº', () => {
      const { wj2 } = require('../../core/plan-mode');
      
      // æµ‹è¯•åŸºæœ¬å¾ªç¯
      expect(wj2({ mode: 'default', isBypassPermissionsModeAvailable: false })).toBe('acceptEdits');
      expect(wj2({ mode: 'acceptEdits', isBypassPermissionsModeAvailable: false })).toBe('plan');
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: false })).toBe('default');
      
      // æµ‹è¯•bypassæƒé™æ¨¡å¼
      expect(wj2({ mode: 'plan', isBypassPermissionsModeAvailable: true })).toBe('bypassPermissions');
      expect(wj2({ mode: 'bypassPermissions', isBypassPermissionsModeAvailable: true })).toBe('default');
    });

    test('Planæ¨¡å¼ç®¡ç†å™¨', () => {
      const { PlanModeManager } = require('../../core/plan-mode');
      const eventLogger = jest.fn();
      const manager = new PlanModeManager('default', 'test-session', eventLogger);
      
      expect(manager.getCurrentMode()).toBe('default');
      
      manager.cyclePlanMode();
      expect(manager.getCurrentMode()).toBe('acceptEdits');
      expect(eventLogger).toHaveBeenCalledWith('tengu_mode_cycle', expect.any(Object));
    });

    test('exit_plan_modeå·¥å…·', async () => {
      const { ExitPlanModeTool } = await import('../../tools/implementations/exit-plan-mode');
      const tool = new ExitPlanModeTool();
      
      const context = TestUtils.createMockToolContext();
      
      // æµ‹è¯•æƒé™æ£€æŸ¥
      const permission = await tool.checkPermissions({ plan: 'Test plan' });
      expect(permission.behavior).toBe('ask');
      
      // æµ‹è¯•å·¥å…·æ‰§è¡Œ
      const generator = tool.call({ plan: 'Test plan' }, context);
      const result = await generator.next();
      
      expect(result.value).toBeDefined();
      expect(result.value.data.plan).toBe('Test plan');
    });

    test('Planæ¨¡å¼ç³»ç»Ÿæé†’', () => {
      const { generatePlanModeSystemReminder, isToolAllowedInPlanMode } = require('../../core/plan-mode');
      
      const reminder = generatePlanModeSystemReminder();
      expect(reminder).toContain('<system-reminder>');
      expect(reminder).toContain('Plan mode is active');
      
      // åªè¯»å·¥å…·åº”è¯¥è¢«å…è®¸
      expect(isToolAllowedInPlanMode('Read')).toBe(true);
      expect(isToolAllowedInPlanMode('LS')).toBe(true);
      
      // ä¿®æ”¹å·¥å…·åº”è¯¥è¢«é˜»æ­¢
      expect(isToolAllowedInPlanMode('Write')).toBe(false);
      expect(isToolAllowedInPlanMode('Edit')).toBe(false);
    });
  });

  describe('MCP Integration', () => {
    test('MCPå®¢æˆ·ç«¯è¿æ¥å’Œé€šä¿¡', async () => {
      const { McpClient } = await import('../../mcp/client');
      const config = TestUtils.createMockMcpServerConfig();
      const client = new McpClient(config);
      
      // æ¨¡æ‹Ÿè¿æ¥
      expect(client.connected).toBe(false);
      
      // æµ‹è¯•å·¥å…·è°ƒç”¨æ ¼å¼
      const toolCall = {
        toolName: 'test_tool',
        arguments: { param: 'value' }
      };
      
      // å®é™…æµ‹è¯•ä¸­ä¼šæ¨¡æ‹ŸMCPå“åº”
      expect(toolCall.toolName).toBe('test_tool');
    });

    test('å¤šæœåŠ¡å™¨ç®¡ç†', async () => {
      const { McpServerManager } = await import('../../mcp/server-manager');
      const manager = new McpServerManager();
      
      const config1 = { ...TestUtils.createMockMcpServerConfig(), name: 'server1' };
      const config2 = { ...TestUtils.createMockMcpServerConfig(), name: 'server2' };
      
      await manager.addServer(config1);
      await manager.addServer(config2);
      
      const states = manager.getAllServerStates();
      expect(states).toHaveLength(2);
      
      const stats = manager.getStatistics();
      expect(stats.total).toBe(2);
    });

    test('å·¥å…·å®‰å…¨å’Œç™½åå•', () => {
      const { ToolSecurityManager } = require('../../mcp/security/tool-whitelist');
      const security = new ToolSecurityManager();
      
      // æµ‹è¯•IDEå·¥å…·ç™½åå•
      expect(security.isToolAllowed('mcp__ide__getDiagnostics')).toBe(true);
      expect(security.isToolAllowed('mcp__ide__executeCode')).toBe(true);
      expect(security.isToolAllowed('mcp__ide__malicious')).toBe(false);
      
      // æµ‹è¯•æƒé™è¦æ±‚
      expect(security.requiresPermission('mcp__ide__executeCode')).toBe(true);
    });

    test('é…ç½®ç®¡ç†ä¸‰çº§å±‚æ¬¡', async () => {
      const { McpConfigManager } = await import('../../mcp/config/config-manager');
      const manager = new McpConfigManager();
      
      // æ¨¡æ‹Ÿé…ç½®åŠ è½½
      await manager.initialize('./test-workspace');
      
      const config = manager.getConfiguration();
      expect(config).toHaveProperty('servers');
      expect(config).toHaveProperty('globalSettings');
      expect(config).toHaveProperty('security');
      
      const validation = manager.validateConfiguration();
      expect(validation).toHaveProperty('valid');
      expect(validation).toHaveProperty('errors');
    });
  });

  describe('IDE Integration', () => {
    test('è¯Šæ–­ä¿¡æ¯ç®¡ç†', () => {
      const { IdeDiagnosticsManager } = require('../../integrations/ide-diagnostics');
      const manager = IdeDiagnosticsManager.getInstance();
      
      // æµ‹è¯•å•ä¾‹æ¨¡å¼
      const manager2 = IdeDiagnosticsManager.getInstance();
      expect(manager).toBe(manager2);
      
      // æµ‹è¯•è¯Šæ–­æ¯”è¾ƒ
      const diag1 = {
        message: 'Error message',
        severity: 1,
        range: { start: { line: 0, character: 0 }, end: { line: 0, character: 5 } }
      };
      
      const diag2 = { ...diag1 };
      expect(manager.areDiagnosticsEqual(diag1, diag2)).toBe(true);
    });

    test('IDEè¿æ¥æ£€æµ‹', () => {
      const { IdeConnectionDetector } = require('../../integrations/ide-diagnostics');
      
      const mockServers = [
        {
          type: 'connected',
          name: 'ide',
          config: { type: 'sse-ide', ideName: 'vscode' }
        }
      ];
      
      const detected = IdeConnectionDetector.detectConnectedIde(mockServers);
      expect(detected).toBe('vscode');
      
      const displayName = IdeConnectionDetector.getIdeDisplayName('vscode');
      expect(displayName).toBe('VS Code');
    });
  });

  describe('UI Components', () => {
    test('Planæ¨¡å¼æŒ‡ç¤ºå™¨', () => {
      const { PlanModeIndicator } = require('../../ui/components/plan-mode-indicator');
      const React = require('react');
      
      const context = {
        currentMode: 'plan',
        previousMode: 'default',
        timestamp: Date.now(),
        sessionId: 'test'
      };
      
      const element = React.createElement(PlanModeIndicator, {
        context,
        theme: { planMode: '#ff0000', secondaryText: '#666666' }
      });
      
      expect(element).toBeDefined();
    });

    test('ç‰¹æ®Šæ¨¡å¼å¤„ç†å™¨', () => {
      const { SpecialModeHandler } = require('../../ui/special-modes');
      const handler = new SpecialModeHandler();
      
      // æµ‹è¯•Bashæ¨¡å¼
      const bashResult = handler.processInput('!ls -la');
      expect(bashResult.mode).toBe('bash');
      expect(bashResult.content).toBe('ls -la');
      
      // æµ‹è¯•ç¬”è®°æ¨¡å¼
      const noteResult = handler.processInput('# Test note #tag');
      expect(noteResult.mode).toBe('note');
      
      const notes = handler.getNotes();
      expect(notes).toHaveLength(1);
      expect(notes[0].tags).toContain('tag');
    });

    test('å¿«æ·æŒ‡ä»¤ç³»ç»Ÿ', async () => {
      const { SlashCommandManager } = require('../../commands/slash-commands');
      const manager = new SlashCommandManager();
      
      const context = {
        sessionId: 'test',
        mcpServers: [],
        currentDirectory: '/test',
        planModeManager: null
      };
      
      // æµ‹è¯•helpå‘½ä»¤
      const helpResult = await manager.execute('/help', context);
      expect(helpResult.success).toBe(true);
      expect(helpResult.message).toContain('Available commands');
      
      // æµ‹è¯•å‘½ä»¤è‡ªåŠ¨è¡¥å…¨
      const completions = manager.getCompletions('/he');
      expect(completions).toContain('/help');
    });
  });

  describe('Error Handling and Edge Cases', () => {
    test('ç½‘ç»œè¿æ¥å¤±è´¥å¤„ç†', async () => {
      // æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯
      const mockFetch = TestUtils.mockNetworkRequests();
      mockFetch.mockRejectedValue(new Error('Network error'));
      
      // æµ‹è¯•HTTPä¼ è¾“é”™è¯¯å¤„ç†
      const { HttpTransport } = await import('../../mcp/transport/http-sse');
      const transport = new HttpTransport({
        type: 'http',
        url: 'http://invalid-url'
      });
      
      await transport.connect();
      await expect(transport.send({ test: 'message' })).rejects.toThrow();
    });

    test('æ–‡ä»¶ç³»ç»Ÿé”™è¯¯å¤„ç†', async () => {
      const mockFs = TestUtils.mockFileSystem();
      mockFs.readFile.mockRejectedValue(new Error('File not found'));
      
      const { ReadTool } = await import('../../tools/implementations/read');
      const tool = new ReadTool();
      const context = TestUtils.createMockToolContext();
      
      const generator = tool.call({ file_path: '/nonexistent.txt' }, context);
      const result = await generator.next();
      
      // åº”è¯¥è¿”å›é”™è¯¯ç»“æœè€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸
      expect(result.value.type).toBe('error');
    });

    test('å¤§é‡æ•°æ®å¤„ç†', async () => {
      const { h2A } = await import('../../core/message-queue');
      const queue = new h2A();
      
      // æµ‹è¯•å¤§é‡æ¶ˆæ¯å¤„ç†
      const messageCount = 10000;
      for (let i = 0; i < messageCount; i++) {
        queue.enqueue({ id: i, data: `message-${i}` });
      }
      
      let processedCount = 0;
      const iterator = queue[Symbol.asyncIterator]();
      
      for (let i = 0; i < messageCount; i++) {
        const result = await iterator.next();
        if (!result.done) {
          processedCount++;
        }
      }
      
      expect(processedCount).toBe(messageCount);
    });

    test('å†…å­˜æ³„æ¼é¢„é˜²', async () => {
      const { McpServerManager } = await import('../../mcp/server-manager');
      const manager = new McpServerManager();
      
      // åˆ›å»ºå¤§é‡è¿æ¥
      const servers = Array.from({ length: 100 }, (_, i) => ({
        name: `test-server-${i}`,
        transport: { type: 'stdio' as const, command: 'echo' }
      }));
      
      for (const config of servers) {
        await manager.addServer(config);
      }
      
      // æ¸…ç†æ‰€æœ‰è¿æ¥
      await manager.cleanup();
      
      // éªŒè¯èµ„æºè¢«æ­£ç¡®æ¸…ç†
      const stats = manager.getStatistics();
      expect(stats.total).toBe(0);
    });

    test('å¹¶å‘ç«äº‰æ¡ä»¶', async () => {
      const { ToolSecurityManager } = require('../../mcp/security/tool-whitelist');
      const security = new ToolSecurityManager();
      
      // å¹¶å‘å·¥å…·è°ƒç”¨éªŒè¯
      const promises = Array.from({ length: 50 }, (_, i) =>
        security.validateToolCall({
          toolName: 'test_tool',
          serverName: 'test',
          arguments: {},
          sessionId: `session-${i}`
        })
      );
      
      const results = await Promise.all(promises);
      expect(results).toHaveLength(50);
      
      // éªŒè¯æ²¡æœ‰ç«äº‰æ¡ä»¶å¯¼è‡´çš„é”™è¯¯
      results.forEach(result => {
        expect(result).toHaveProperty('allowed');
      });
    });
  });
});

/**
 * è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶
 */
export async function runCompleteTestSuite(): Promise<void> {
  console.log('ğŸš€ å¼€å§‹è¿è¡Œ Open Claude Code å®Œæ•´æµ‹è¯•å¥—ä»¶...\n');
  
  const testFiles = [
    './stage1-agent-core.test.ts',
    './stage2-tool-system.test.ts', 
    './stage3-integration.test.ts',
    './stage4-mcp-integration.test.ts',
    './coverage/test-suite.ts'
  ];
  
  let totalTests = 0;
  let passedTests = 0;
  let failedTests = 0;
  
  for (const testFile of testFiles) {
    console.log(`ğŸ“‹ è¿è¡Œæµ‹è¯•æ–‡ä»¶: ${testFile}`);
    
    try {
      // è¿™é‡Œä¼šè¿è¡Œå®é™…çš„Jestæµ‹è¯•
      const result = await runJestTests(testFile);
      totalTests += result.total;
      passedTests += result.passed;
      failedTests += result.failed;
      
      console.log(`âœ… ${testFile}: ${result.passed}/${result.total} é€šè¿‡\n`);
    } catch (error) {
      console.error(`âŒ ${testFile}: æµ‹è¯•å¤±è´¥`, error);
      failedTests++;
    }
  }
  
  console.log('ğŸ“Š æµ‹è¯•æ€»ç»“:');
  console.log(`- æ€»æµ‹è¯•æ•°: ${totalTests}`);
  console.log(`- é€šè¿‡: ${passedTests}`);
  console.log(`- å¤±è´¥: ${failedTests}`);
  console.log(`- æˆåŠŸç‡: ${((passedTests / totalTests) * 100).toFixed(2)}%`);
  
  if (failedTests === 0) {
    console.log('\nğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ä»£ç è´¨é‡è¾¾æ ‡ã€‚');
  } else {
    console.log(`\nâš ï¸  æœ‰ ${failedTests} ä¸ªæµ‹è¯•å¤±è´¥ï¼Œéœ€è¦ä¿®å¤ã€‚`);
  }
}

/**
 * æ¨¡æ‹ŸJestæµ‹è¯•è¿è¡Œå™¨
 */
async function runJestTests(testFile: string): Promise<{ total: number; passed: number; failed: number }> {
  // å®é™…å®ç°ä¸­ä¼šè°ƒç”¨Jest API
  return {
    total: 10,
    passed: 10,
    failed: 0
  };
}
```

### æ­¥éª¤5.3: å†…å­˜å’Œæ€§èƒ½ä¼˜åŒ–

**é’ˆå¯¹æ€§èƒ½ç“¶é¢ˆè¿›è¡Œç³»ç»Ÿä¼˜åŒ–**

**æ–‡ä»¶è·¯å¾„**: `src/optimizations/performance-optimizer.ts`
**æ–‡ä»¶å†…å®¹**:
```typescript
/**
 * Open Claude Code æ€§èƒ½ä¼˜åŒ–å™¨
 * é’ˆå¯¹å…³é”®æ€§èƒ½ç“¶é¢ˆè¿›è¡Œç³»ç»Ÿçº§ä¼˜åŒ–
 */

/**
 * å†…å­˜ä¼˜åŒ–ç®¡ç†å™¨
 */
export class MemoryOptimizer {
  private memoryThreshold = 512 * 1024 * 1024; // 512MB
  private gcInterval: NodeJS.Timeout | null = null;
  private memoryUsageHistory: number[] = [];
  
  /**
   * å¯åŠ¨å†…å­˜ç›‘æ§
   */
  public startMonitoring(): void {
    this.gcInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }

  /**
   * åœæ­¢å†…å­˜ç›‘æ§
   */
  public stopMonitoring(): void {
    if (this.gcInterval) {
      clearInterval(this.gcInterval);
      this.gcInterval = null;
    }
  }

  /**
   * æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
   */
  private checkMemoryUsage(): void {
    const usage = process.memoryUsage();
    this.memoryUsageHistory.push(usage.heapUsed);
    
    // ä¿ç•™æœ€è¿‘20æ¬¡è®°å½•
    if (this.memoryUsageHistory.length > 20) {
      this.memoryUsageHistory.shift();
    }
    
    // å¦‚æœå†…å­˜ä½¿ç”¨è¶…è¿‡é˜ˆå€¼ï¼Œè§¦å‘ä¼˜åŒ–
    if (usage.heapUsed > this.memoryThreshold) {
      this.optimizeMemory();
    }
    
    // æ£€æµ‹å†…å­˜æ³„æ¼
    if (this.detectMemoryLeak()) {
      console.warn('âš ï¸ æ£€æµ‹åˆ°å¯èƒ½çš„å†…å­˜æ³„æ¼');
      this.forceGarbageCollection();
    }
  }

  /**
   * æ£€æµ‹å†…å­˜æ³„æ¼
   */
  private detectMemoryLeak(): boolean {
    if (this.memoryUsageHistory.length < 10) return false;
    
    // æ£€æŸ¥å†…å­˜æ˜¯å¦æŒç»­å¢é•¿
    const recent = this.memoryUsageHistory.slice(-5);
    const earlier = this.memoryUsageHistory.slice(-10, -5);
    
    const recentAvg = recent.reduce((sum, val) => sum + val, 0) / recent.length;
    const earlierAvg = earlier.reduce((sum, val) => sum + val, 0) / earlier.length;
    
    // å¦‚æœæœ€è¿‘5æ¬¡çš„å¹³å‡å€¼æ¯”ä¹‹å‰5æ¬¡é«˜å‡º20%ä»¥ä¸Šï¼Œå¯èƒ½å­˜åœ¨å†…å­˜æ³„æ¼
    return (recentAvg - earlierAvg) / earlierAvg > 0.2;
  }

  /**
   * æ‰§è¡Œå†…å­˜ä¼˜åŒ–
   */
  public optimizeMemory(): void {
    console.log('ğŸ”§ æ‰§è¡Œå†…å­˜ä¼˜åŒ–...');
    
    // 1. æ¸…ç†æ¶ˆæ¯é˜Ÿåˆ—ç¼“å­˜
    this.clearMessageQueueCache();
    
    // 2. æ¸…ç†å·¥å…·æ‰§è¡Œå†å²
    this.clearToolExecutionHistory();
    
    // 3. æ¸…ç†MCPè¿æ¥ç¼“å­˜
    this.clearMcpConnectionCache();
    
    // 4. å¼ºåˆ¶åƒåœ¾å›æ”¶
    this.forceGarbageCollection();
    
    console.log('âœ… å†…å­˜ä¼˜åŒ–å®Œæˆ');
  }

  /**
   * æ¸…ç†æ¶ˆæ¯é˜Ÿåˆ—ç¼“å­˜
   */
  private clearMessageQueueCache(): void {
    // å®ç°æ¶ˆæ¯é˜Ÿåˆ—ç¼“å­˜æ¸…ç†
    try {
      const { globalMessageQueue } = require('../core/message-queue');
      if (globalMessageQueue && typeof globalMessageQueue.clearCache === 'function') {
        globalMessageQueue.clearCache();
      }
    } catch (error) {
      console.warn('æ¸…ç†æ¶ˆæ¯é˜Ÿåˆ—ç¼“å­˜æ—¶å‡ºé”™:', error);
    }
  }

  /**
   * æ¸…ç†å·¥å…·æ‰§è¡Œå†å²
   */
  private clearToolExecutionHistory(): void {
    try {
      const { globalToolSecurity } = require('../mcp/security/tool-whitelist');
      if (globalToolSecurity && typeof globalToolSecurity.cleanupViolations === 'function') {
        globalToolSecurity.cleanupViolations();
      }
    } catch (error) {
      console.warn('æ¸…ç†å·¥å…·æ‰§è¡Œå†å²æ—¶å‡ºé”™:', error);
    }
  }

  /**
   * æ¸…ç†MCPè¿æ¥ç¼“å­˜
   */
  private clearMcpConnectionCache(): void {
    try {
      const { globalServerManager } = require('../mcp/server-manager');
      if (globalServerManager && typeof globalServerManager.clearCache === 'function') {
        globalServerManager.clearCache();
      }
    } catch (error) {
      console.warn('æ¸…ç†MCPè¿æ¥ç¼“å­˜æ—¶å‡ºé”™:', error);
    }
  }

  /**
   * å¼ºåˆ¶åƒåœ¾å›æ”¶
   */
  private forceGarbageCollection(): void {
    if (global.gc) {
      global.gc();
      console.log('ğŸ—‘ï¸ æ‰§è¡Œåƒåœ¾å›æ”¶');
    } else {
      console.warn('åƒåœ¾å›æ”¶ä¸å¯ç”¨ï¼Œéœ€è¦ä½¿ç”¨ --expose-gc æ ‡å¿—å¯åŠ¨');
    }
  }

  /**
   * è·å–å†…å­˜ä½¿ç”¨æŠ¥å‘Š
   */
  public getMemoryReport(): {
    current: NodeJS.MemoryUsage;
    threshold: number;
    history: number[];
    recommendation: string;
  } {
    const current = process.memoryUsage();
    let recommendation = 'å†…å­˜ä½¿ç”¨æ­£å¸¸';
    
    if (current.heapUsed > this.memoryThreshold) {
      recommendation = 'å†…å­˜ä½¿ç”¨è¿‡é«˜ï¼Œå»ºè®®ä¼˜åŒ–';
    } else if (this.detectMemoryLeak()) {
      recommendation = 'æ£€æµ‹åˆ°å†…å­˜æ³„æ¼ï¼Œéœ€è¦è°ƒæŸ¥';
    }
    
    return {
      current,
      threshold: this.memoryThreshold,
      history: [...this.memoryUsageHistory],
      recommendation
    };
  }
}

/**
 * å“åº”æ—¶é—´ä¼˜åŒ–å™¨
 */
export class ResponseTimeOptimizer {
  private responseTimeCache = new Map<string, number>();
  private optimizationStrategies = new Map<string, () => void>();
  
  constructor() {
    this.initializeStrategies();
  }

  /**
   * åˆå§‹åŒ–ä¼˜åŒ–ç­–ç•¥
   */
  private initializeStrategies(): void {
    this.optimizationStrategies.set('agent-core', () => {
      // Agentæ ¸å¿ƒä¼˜åŒ–
      this.optimizeAgentCore();
    });
    
    this.optimizationStrategies.set('tool-execution', () => {
      // å·¥å…·æ‰§è¡Œä¼˜åŒ–
      this.optimizeToolExecution();
    });
    
    this.optimizationStrategies.set('mcp-connections', () => {
      // MCPè¿æ¥ä¼˜åŒ–
      this.optimizeMcpConnections();
    });
    
    this.optimizationStrategies.set('ui-rendering', () => {
      // UIæ¸²æŸ“ä¼˜åŒ–
      this.optimizeUIRendering();
    });
  }

  /**
   * è®°å½•å“åº”æ—¶é—´
   */
  public recordResponseTime(operation: string, time: number): void {
    this.responseTimeCache.set(operation, time);
    
    // å¦‚æœå“åº”æ—¶é—´è¶…è¿‡é˜ˆå€¼ï¼Œè§¦å‘ä¼˜åŒ–
    const threshold = this.getThreshold(operation);
    if (time > threshold) {
      this.triggerOptimization(operation);
    }
  }

  /**
   * è·å–æ“ä½œçš„å“åº”æ—¶é—´é˜ˆå€¼
   */
  private getThreshold(operation: string): number {
    const thresholds = {
      'agent-core': 2000,      // 2ç§’
      'tool-execution': 1000,   // 1ç§’
      'mcp-connections': 500,   // 500ms
      'ui-rendering': 100,      // 100ms
      'plan-mode': 200         // 200ms
    };
    
    return thresholds[operation] || 1000;
  }

  /**
   * è§¦å‘ä¼˜åŒ–
   */
  private triggerOptimization(operation: string): void {
    console.log(`ğŸš€ è§¦å‘ ${operation} ä¼˜åŒ–...`);
    
    const strategy = this.optimizationStrategies.get(operation);
    if (strategy) {
      strategy();
    }
  }

  /**
   * ä¼˜åŒ–Agentæ ¸å¿ƒ
   */
  private optimizeAgentCore(): void {
    // 1. å¯ç”¨æ¶ˆæ¯å‹ç¼©
    this.enableMessageCompression();
    
    // 2. ä¼˜åŒ–Steeringé˜Ÿåˆ—
    this.optimizeSteeringQueue();
    
    // 3. å¯ç”¨å“åº”ç¼“å­˜
    this.enableResponseCaching();
  }

  /**
   * å¯ç”¨æ¶ˆæ¯å‹ç¼©
   */
  private enableMessageCompression(): void {
    try {
      const { AgentCore } = require('../core/agent-core');
      if (AgentCore.prototype.enableCompression) {
        AgentCore.prototype.enableCompression(true);
        console.log('âœ… å¯ç”¨æ¶ˆæ¯å‹ç¼©');
      }
    } catch (error) {
      console.warn('å¯ç”¨æ¶ˆæ¯å‹ç¼©å¤±è´¥:', error);
    }
  }

  /**
   * ä¼˜åŒ–Steeringé˜Ÿåˆ—
   */
  private optimizeSteeringQueue(): void {
    try {
      const { h2A } = require('../core/message-queue');
      if (h2A.prototype.enableBatching) {
        h2A.prototype.enableBatching(true);
        console.log('âœ… å¯ç”¨Steeringé˜Ÿåˆ—æ‰¹å¤„ç†');
      }
    } catch (error) {
      console.warn('ä¼˜åŒ–Steeringé˜Ÿåˆ—å¤±è´¥:', error);
    }
  }

  /**
   * å¯ç”¨å“åº”ç¼“å­˜
   */
  private enableResponseCaching(): void {
    // å®ç°å“åº”ç¼“å­˜é€»è¾‘
    console.log('âœ… å¯ç”¨å“åº”ç¼“å­˜');
  }

  /**
   * ä¼˜åŒ–å·¥å…·æ‰§è¡Œ
   */
  private optimizeToolExecution(): void {
    // 1. å¯ç”¨å·¥å…·æ‰§è¡Œæ± 
    this.enableToolExecutionPool();
    
    // 2. ä¼˜åŒ–å¹¶å‘æ§åˆ¶
    this.optimizeConcurrencyControl();
  }

  /**
   * å¯ç”¨å·¥å…·æ‰§è¡Œæ± 
   */
  private enableToolExecutionPool(): void {
    try {
      const { ToolRegistry } = require('../tools/registry');
      if (ToolRegistry.prototype.enablePool) {
        ToolRegistry.prototype.enablePool(10); // æ± å¤§å°ä¸º10
        console.log('âœ… å¯ç”¨å·¥å…·æ‰§è¡Œæ± ');
      }
    } catch (error) {
      console.warn('å¯ç”¨å·¥å…·æ‰§è¡Œæ± å¤±è´¥:', error);
    }
  }

  /**
   * ä¼˜åŒ–å¹¶å‘æ§åˆ¶
   */
  private optimizeConcurrencyControl(): void {
    try {
      const { globalToolSecurity } = require('../mcp/security/tool-whitelist');
      if (globalToolSecurity && globalToolSecurity.updatePolicy) {
        globalToolSecurity.updatePolicy({
          maxConcurrentCalls: 15 // å¢åŠ å¹¶å‘é™åˆ¶
        });
        console.log('âœ… ä¼˜åŒ–å¹¶å‘æ§åˆ¶');
      }
    } catch (error) {
      console.warn('ä¼˜åŒ–å¹¶å‘æ§åˆ¶å¤±è´¥:', error);
    }
  }

  /**
   * ä¼˜åŒ–MCPè¿æ¥
   */
  private optimizeMcpConnections(): void {
    // 1. å¯ç”¨è¿æ¥æ± 
    this.enableConnectionPooling();
    
    // 2. ä¼˜åŒ–å¿ƒè·³æœºåˆ¶
    this.optimizeHeartbeat();
    
    // 3. å¯ç”¨è¯·æ±‚æ‰¹å¤„ç†
    this.enableRequestBatching();
  }

  /**
   * å¯ç”¨è¿æ¥æ± 
   */
  private enableConnectionPooling(): void {
    try {
      const { globalServerManager } = require('../mcp/server-manager');
      if (globalServerManager && globalServerManager.enablePooling) {
        globalServerManager.enablePooling(true);
        console.log('âœ… å¯ç”¨MCPè¿æ¥æ± ');
      }
    } catch (error) {
      console.warn('å¯ç”¨è¿æ¥æ± å¤±è´¥:', error);
    }
  }

  /**
   * ä¼˜åŒ–å¿ƒè·³æœºåˆ¶
   */
  private optimizeHeartbeat(): void {
    // å®ç°å¿ƒè·³ä¼˜åŒ–
    console.log('âœ… ä¼˜åŒ–å¿ƒè·³æœºåˆ¶');
  }

  /**
   * å¯ç”¨è¯·æ±‚æ‰¹å¤„ç†
   */
  private enableRequestBatching(): void {
    // å®ç°è¯·æ±‚æ‰¹å¤„ç†
    console.log('âœ… å¯ç”¨è¯·æ±‚æ‰¹å¤„ç†');
  }

  /**
   * ä¼˜åŒ–UIæ¸²æŸ“
   */
  private optimizeUIRendering(): void {
    // 1. å¯ç”¨è™šæ‹ŸåŒ–
    this.enableVirtualization();
    
    // 2. ä¼˜åŒ–é‡æ¸²æŸ“
    this.optimizeRerendering();
  }

  /**
   * å¯ç”¨è™šæ‹ŸåŒ–
   */
  private enableVirtualization(): void {
    // å®ç°UIè™šæ‹ŸåŒ–
    console.log('âœ… å¯ç”¨UIè™šæ‹ŸåŒ–');
  }

  /**
   * ä¼˜åŒ–é‡æ¸²æŸ“
   */
  private optimizeRerendering(): void {
    // å®ç°é‡æ¸²æŸ“ä¼˜åŒ–
    console.log('âœ… ä¼˜åŒ–UIé‡æ¸²æŸ“');
  }

  /**
   * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
   */
  public generatePerformanceReport(): string {
    const report = ['# æ€§èƒ½ä¼˜åŒ–æŠ¥å‘Š\n'];
    
    report.push('## å“åº”æ—¶é—´ç»Ÿè®¡\n');
    for (const [operation, time] of this.responseTimeCache) {
      const threshold = this.getThreshold(operation);
      const status = time <= threshold ? 'âœ…' : 'âŒ';
      report.push(`- ${operation}: ${time.toFixed(2)}ms (é˜ˆå€¼: ${threshold}ms) ${status}`);
    }
    
    report.push('\n## å·²åº”ç”¨çš„ä¼˜åŒ–ç­–ç•¥\n');
    for (const strategy of this.optimizationStrategies.keys()) {
      report.push(`- ${strategy}: å·²ä¼˜åŒ–`);
    }
    
    return report.join('\n');
  }
}

/**
 * ç½‘ç»œä¼˜åŒ–å™¨
 */
export class NetworkOptimizer {
  private connectionPool = new Map<string, any[]>();
  private maxConnectionsPerHost = 10;
  private requestQueue = new Map<string, any[]>();
  
  /**
   * ä¼˜åŒ–HTTPè¯·æ±‚
   */
  public optimizeHttpRequests(): void {
    // 1. å¯ç”¨è¿æ¥å¤ç”¨
    this.enableConnectionReuse();
    
    // 2. å®ç°è¯·æ±‚åˆå¹¶
    this.enableRequestBatching();
    
    // 3. å¯ç”¨å‹ç¼©
    this.enableCompression();
  }

  /**
   * å¯ç”¨è¿æ¥å¤ç”¨
   */
  private enableConnectionReuse(): void {
    const http = require('http');
    const https = require('https');
    
    // é…ç½®Agentä»¥å¯ç”¨è¿æ¥å¤ç”¨
    const httpAgent = new http.Agent({
      keepAlive: true,
      maxSockets: this.maxConnectionsPerHost
    });
    
    const httpsAgent = new https.Agent({
      keepAlive: true,
      maxSockets: this.maxConnectionsPerHost
    });
    
    // å°†è¿™äº›Agentè®¾ç½®ä¸ºé»˜è®¤
    http.globalAgent = httpAgent;
    https.globalAgent = httpsAgent;
    
    console.log('âœ… å¯ç”¨HTTPè¿æ¥å¤ç”¨');
  }

  /**
   * å¯ç”¨è¯·æ±‚åˆå¹¶
   */
  private enableRequestBatching(): void {
    // å®ç°è¯·æ±‚æ‰¹å¤„ç†é€»è¾‘
    console.log('âœ… å¯ç”¨è¯·æ±‚åˆå¹¶');
  }

  /**
   * å¯ç”¨å‹ç¼©
   */
  private enableCompression(): void {
    // ä¸ºæ‰€æœ‰HTTPè¯·æ±‚å¯ç”¨gzipå‹ç¼©
    const defaultHeaders = {
      'Accept-Encoding': 'gzip, deflate, br',
      'Connection': 'keep-alive'
    };
    
    // å°†è¿™äº›å¤´éƒ¨åº”ç”¨åˆ°æ‰€æœ‰è¯·æ±‚
    console.log('âœ… å¯ç”¨HTTPå‹ç¼©');
  }
}

/**
 * å…¨å±€æ€§èƒ½ä¼˜åŒ–ç®¡ç†å™¨
 */
export class GlobalPerformanceOptimizer {
  private memoryOptimizer: MemoryOptimizer;
  private responseTimeOptimizer: ResponseTimeOptimizer;
  private networkOptimizer: NetworkOptimizer;
  private isOptimizationEnabled = false;
  
  constructor() {
    this.memoryOptimizer = new MemoryOptimizer();
    this.responseTimeOptimizer = new ResponseTimeOptimizer();
    this.networkOptimizer = new NetworkOptimizer();
  }

  /**
   * å¯ç”¨å…¨å±€æ€§èƒ½ä¼˜åŒ–
   */
  public enableOptimizations(): void {
    if (this.isOptimizationEnabled) return;
    
    console.log('ğŸš€ å¯ç”¨ Open Claude Code æ€§èƒ½ä¼˜åŒ–...');
    
    // 1. å¯åŠ¨å†…å­˜ç›‘æ§
    this.memoryOptimizer.startMonitoring();
    
    // 2. ä¼˜åŒ–ç½‘ç»œè¯·æ±‚
    this.networkOptimizer.optimizeHttpRequests();
    
    // 3. è®¾ç½®æ€§èƒ½ç›‘æ§
    this.setupPerformanceMonitoring();
    
    // 4. åº”ç”¨å¯åŠ¨ä¼˜åŒ–
    this.applyStartupOptimizations();
    
    this.isOptimizationEnabled = true;
    console.log('âœ… æ€§èƒ½ä¼˜åŒ–å·²å¯ç”¨');
  }

  /**
   * ç¦ç”¨æ€§èƒ½ä¼˜åŒ–
   */
  public disableOptimizations(): void {
    if (!this.isOptimizationEnabled) return;
    
    this.memoryOptimizer.stopMonitoring();
    this.isOptimizationEnabled = false;
    
    console.log('ğŸ›‘ æ€§èƒ½ä¼˜åŒ–å·²ç¦ç”¨');
  }

  /**
   * è®¾ç½®æ€§èƒ½ç›‘æ§
   */
  private setupPerformanceMonitoring(): void {
    // ç›‘æ§å…³é”®æ“ä½œçš„æ€§èƒ½
    this.instrumentFunction('AgentCore', 'mainLoop', 'agent-core');
    this.instrumentFunction('ToolRegistry', 'executeTool', 'tool-execution');
    this.instrumentFunction('McpClient', 'callTool', 'mcp-connections');
  }

  /**
   * ä¸ºå‡½æ•°æ·»åŠ æ€§èƒ½ç›‘æ§
   */
  private instrumentFunction(className: string, methodName: string, operationName: string): void {
    try {
      const classModule = require(`../core/${className.toLowerCase()}`);
      const originalMethod = classModule[className].prototype[methodName];
      
      if (originalMethod) {
        classModule[className].prototype[methodName] = async function(...args: any[]) {
          const startTime = performance.now();
          const result = await originalMethod.apply(this, args);
          const endTime = performance.now();
          
          this.responseTimeOptimizer.recordResponseTime(operationName, endTime - startTime);
          
          return result;
        };
      }
    } catch (error) {
      console.warn(`æ— æ³•ä¸º ${className}.${methodName} æ·»åŠ æ€§èƒ½ç›‘æ§:`, error);
    }
  }

  /**
   * åº”ç”¨å¯åŠ¨ä¼˜åŒ–
   */
  private applyStartupOptimizations(): void {
    // 1. é¢„åŠ è½½å…³é”®æ¨¡å—
    this.preloadCriticalModules();
    
    // 2. åˆå§‹åŒ–ç¼“å­˜
    this.initializeCaches();
    
    // 3. è®¾ç½®æ€§èƒ½è°ƒä¼˜å‚æ•°
    this.configurePerformanceTuning();
  }

  /**
   * é¢„åŠ è½½å…³é”®æ¨¡å—
   */
  private preloadCriticalModules(): void {
    const criticalModules = [
      '../core/agent-core',
      '../core/message-queue',
      '../tools/registry',
      '../mcp/client'
    ];
    
    for (const module of criticalModules) {
      try {
        require(module);
      } catch (error) {
        console.warn(`é¢„åŠ è½½æ¨¡å— ${module} å¤±è´¥:`, error);
      }
    }
    
    console.log('âœ… å…³é”®æ¨¡å—é¢„åŠ è½½å®Œæˆ');
  }

  /**
   * åˆå§‹åŒ–ç¼“å­˜
   */
  private initializeCaches(): void {
    // åˆå§‹åŒ–å„ç§ç¼“å­˜
    console.log('âœ… ç¼“å­˜åˆå§‹åŒ–å®Œæˆ');
  }

  /**
   * é…ç½®æ€§èƒ½è°ƒä¼˜å‚æ•°
   */
  private configurePerformanceTuning(): void {
    // è°ƒæ•´Node.jsæ€§èƒ½å‚æ•°
    if (process.env.NODE_ENV === 'production') {
      process.env.UV_THREADPOOL_SIZE = '16'; // å¢åŠ çº¿ç¨‹æ± å¤§å°
    }
    
    console.log('âœ… æ€§èƒ½è°ƒä¼˜å‚æ•°é…ç½®å®Œæˆ');
  }

  /**
   * ç”Ÿæˆç»¼åˆæ€§èƒ½æŠ¥å‘Š
   */
  public generateComprehensiveReport(): string {
    const report = ['# Open Claude Code ç»¼åˆæ€§èƒ½æŠ¥å‘Š\n'];
    
    // å†…å­˜æŠ¥å‘Š
    const memoryReport = this.memoryOptimizer.getMemoryReport();
    report.push('## å†…å­˜ä½¿ç”¨æŠ¥å‘Š');
    report.push(`- å½“å‰å †å†…å­˜: ${(memoryReport.current.heapUsed / 1024 / 1024).toFixed(2)}MB`);
    report.push(`- å†…å­˜é˜ˆå€¼: ${(memoryReport.threshold / 1024 / 1024).toFixed(2)}MB`);
    report.push(`- å»ºè®®: ${memoryReport.recommendation}\n`);
    
    // å“åº”æ—¶é—´æŠ¥å‘Š
    report.push(this.responseTimeOptimizer.generatePerformanceReport());
    
    // ä¼˜åŒ–çŠ¶æ€
    report.push('\n## ä¼˜åŒ–çŠ¶æ€');
    report.push(`- æ€§èƒ½ä¼˜åŒ–: ${this.isOptimizationEnabled ? 'âœ… å·²å¯ç”¨' : 'âŒ æœªå¯ç”¨'}`);
    report.push(`- å†…å­˜ç›‘æ§: ${this.memoryOptimizer ? 'âœ… è¿è¡Œä¸­' : 'âŒ æœªè¿è¡Œ'}`);
    
    return report.join('\n');
  }
}

/**
 * å…¨å±€æ€§èƒ½ä¼˜åŒ–å™¨å®ä¾‹
 */
export const globalPerformanceOptimizer = new GlobalPerformanceOptimizer();
```

---

## ğŸ“ ç¬¬äºŒå‘¨ï¼šæ–‡æ¡£å®Œå–„å’Œå‘å¸ƒå‡†å¤‡

### æ­¥éª¤5.4: ç”¨æˆ·æ–‡æ¡£å’Œå¼€å‘æŒ‡å—

**åˆ›å»ºå®Œæ•´çš„ç”¨æˆ·å’Œå¼€å‘è€…æ–‡æ¡£**

**æ–‡ä»¶è·¯å¾„**: `docs/README.md`
**æ–‡ä»¶å†…å®¹**:
```markdown
# Open Claude Code

ä¸€ä¸ªå®Œå…¨å¼€æºçš„AIç¼–ç¨‹åŠ©æ‰‹ï¼ŒåŸºäºClaude Codeé€†å‘åˆ†æé‡æ–°å®ç°ï¼Œæä¾›ä¸åŸç‰ˆç›¸åŒçš„å¼ºå¤§åŠŸèƒ½ã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹

### å®‰è£…

```bash
# ä½¿ç”¨ npm å®‰è£…
npm install -g open-claude-code

# ä½¿ç”¨ yarn å®‰è£…
yarn global add open-claude-code

# ä½¿ç”¨ pnpm å®‰è£…
pnpm add -g open-claude-code
```

### åŸºæœ¬ä½¿ç”¨

```bash
# å¯åŠ¨äº¤äº’å¼æ¨¡å¼
claude

# ç›´æ¥æ‰§è¡Œå‘½ä»¤
claude "åˆ›å»ºä¸€ä¸ªPython webåº”ç”¨"

# æŸ¥çœ‹å¸®åŠ©
claude --help

# æŸ¥çœ‹ç‰ˆæœ¬
claude --version
```

## âœ¨ æ ¸å¿ƒç‰¹æ€§

### ğŸ§  æ™ºèƒ½Agentç³»ç»Ÿ
- **å®æ—¶Steeringæœºåˆ¶**: åœ¨AIæ‰§è¡Œè¿‡ç¨‹ä¸­å®æ—¶å¼•å¯¼å’Œè°ƒæ•´
- **åˆ†å±‚å¤šAgentæ¶æ„**: æ”¯æŒå¹¶è¡Œå­ä»»åŠ¡æ‰§è¡Œ
- **æ¶ˆæ¯å‹ç¼©å’Œä¼˜åŒ–**: æ™ºèƒ½ç®¡ç†é•¿å¯¹è¯å†å²

### ğŸ› ï¸ å¼ºå¤§çš„å·¥å…·ç³»ç»Ÿ
- **15+å†…ç½®å·¥å…·**: æ–‡ä»¶æ“ä½œã€ä»£ç æœç´¢ã€ç³»ç»Ÿå‘½ä»¤ç­‰
- **å¹¶å‘æ‰§è¡Œæ§åˆ¶**: æ™ºèƒ½ç®¡ç†å·¥å…·æ‰§è¡Œå’Œèµ„æºåˆ†é…
- **å®‰å…¨æƒé™éªŒè¯**: ç¡®ä¿å®‰å…¨çš„å·¥å…·æ‰§è¡Œç¯å¢ƒ

### ğŸ“‹ Planæ¨¡å¼
- **å®‰å…¨åˆ†ææ¨¡å¼**: åœ¨æ‰§è¡Œå‰åˆ¶å®šå’Œå®¡æŸ¥è®¡åˆ’
- **4çŠ¶æ€å¾ªç¯**: default â†’ acceptEdits â†’ plan â†’ bypassPermissions
- **ç”¨æˆ·ç¡®è®¤æœºåˆ¶**: å®Œå…¨æ§åˆ¶AIçš„æ‰§è¡Œè¿‡ç¨‹

### ğŸ”Œ MCPç”Ÿæ€ç³»ç»Ÿ
- **å¤šåè®®æ”¯æŒ**: STDIOã€HTTPã€SSEã€WebSocketå››ç§ä¼ è¾“æ–¹å¼
- **IDEæ·±åº¦é›†æˆ**: VS Codeã€Cursorã€Windsurfç­‰ä¸»æµIDE
- **æ‰©å±•æ’ä»¶ç³»ç»Ÿ**: æ”¯æŒç¬¬ä¸‰æ–¹å·¥å…·å’ŒæœåŠ¡é›†æˆ

### ğŸ’¬ ç‰¹æ®Šäº¤äº’æ¨¡å¼
- **!bashæ¨¡å¼**: ç›´æ¥æ‰§è¡Œå‘½ä»¤è¡ŒæŒ‡ä»¤
- **#ç¬”è®°æ¨¡å¼**: æ™ºèƒ½ç¬”è®°è®°å½•å’Œç®¡ç†
- **å¤šè¡Œè¾“å…¥**: æ”¯æŒä»£ç å—å’Œå¤æ‚è¾“å…¥
- **15+å¿«æ·æŒ‡ä»¤**: /helpã€/mcpã€/statusç­‰ä¾¿æ·å‘½ä»¤

## ğŸ“– ä½¿ç”¨æŒ‡å—

### åŸºæœ¬å¯¹è¯

å¯åŠ¨Open Claude Codeåï¼Œä½ å¯ä»¥ç›´æ¥ä¸AIå¯¹è¯ï¼š

```
ä½ å¥½ï¼æˆ‘æ˜¯Open Claude Codeï¼Œä¸€ä¸ªå¼ºå¤§çš„AIç¼–ç¨‹åŠ©æ‰‹ã€‚

ğŸ‘¤ User: å¸®æˆ‘åˆ›å»ºä¸€ä¸ªç®€å•çš„Node.jsé¡¹ç›®

ğŸ¤– Claude: æˆ‘æ¥å¸®ä½ åˆ›å»ºä¸€ä¸ªNode.jsé¡¹ç›®ã€‚è®©æˆ‘å…ˆæ£€æŸ¥å½“å‰ç›®å½•ç»“æ„ï¼Œç„¶ååˆ›å»ºå¿…è¦çš„æ–‡ä»¶ã€‚

[å·¥å…·æ‰§è¡Œ: LS]
[å·¥å…·æ‰§è¡Œ: Write package.json]
[å·¥å…·æ‰§è¡Œ: Write index.js]

é¡¹ç›®åˆ›å»ºå®Œæˆï¼æˆ‘å·²ç»ä¸ºä½ åˆ›å»ºäº†ï¼š
- package.jsonï¼šé¡¹ç›®é…ç½®æ–‡ä»¶
- index.jsï¼šä¸»å…¥å£æ–‡ä»¶
- åŸºæœ¬çš„é¡¹ç›®ç»“æ„

ä½ å¯ä»¥è¿è¡Œ `npm start` æ¥å¯åŠ¨é¡¹ç›®ã€‚
```

### Planæ¨¡å¼ä½¿ç”¨

Planæ¨¡å¼è®©ä½ å¯ä»¥åœ¨AIæ‰§è¡Œå‰å®¡æŸ¥è®¡åˆ’ï¼š

```bash
# ä½¿ç”¨Shift+Tabåˆ‡æ¢åˆ°Planæ¨¡å¼
# æˆ–ä½¿ç”¨å‘½ä»¤
claude --mode plan
```

åœ¨Planæ¨¡å¼ä¸‹ï¼š
1. AIä¼šåˆ†æä»»åŠ¡å¹¶åˆ¶å®šè¯¦ç»†è®¡åˆ’
2. æ˜¾ç¤ºå°†è¦æ‰§è¡Œçš„æ‰€æœ‰æ“ä½œ
3. ç­‰å¾…ä½ çš„ç¡®è®¤æ‰å¼€å§‹æ‰§è¡Œ
4. å¯ä»¥ä¿®æ”¹æˆ–æ‹’ç»è®¡åˆ’

### ç‰¹æ®Šäº¤äº’æ¨¡å¼

#### Bashæ¨¡å¼
ç›´æ¥æ‰§è¡Œç³»ç»Ÿå‘½ä»¤ï¼š
```
!ls -la
!git status
!npm install
```

#### ç¬”è®°æ¨¡å¼
è®°å½•é‡è¦ä¿¡æ¯ï¼š
```
# è¿™æ˜¯ä¸€ä¸ªé‡è¦çš„APIç«¯ç‚¹ #api #important
# éœ€è¦è®°ä½çš„é…ç½®é€‰é¡¹ #config #todo
```

#### å¿«æ·æŒ‡ä»¤
ä½¿ç”¨æ–œæ å‘½ä»¤å¿«é€Ÿæ‰§è¡Œæ“ä½œï¼š
```
/help          # æ˜¾ç¤ºå¸®åŠ©
/status        # æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€
/mcp list      # æŸ¥çœ‹MCPæœåŠ¡å™¨
/clear         # æ¸…é™¤å¯¹è¯å†å²
/mode plan     # åˆ‡æ¢åˆ°Planæ¨¡å¼
```

### MCPæœåŠ¡å™¨é…ç½®

åˆ›å»º `.mcp.json` é…ç½®æ–‡ä»¶ï¼š

```json
{
  "servers": {
    "my-database": {
      "name": "my-database",
      "transport": {
        "type": "stdio",
        "command": "python",
        "args": ["my-db-server.py"]
      }
    },
    "web-service": {
      "name": "web-service", 
      "transport": {
        "type": "http",
        "url": "http://localhost:8080/mcp"
      }
    }
  }
}
```

### IDEé›†æˆ

#### VS Code
1. å®‰è£…Open Claude Codeæ‰©å±•
2. é…ç½®MCPè¿æ¥ï¼š
```json
{
  "servers": {
    "vscode-integration": {
      "name": "vscode-integration",
      "transport": {
        "type": "sse-ide",
        "url": "http://localhost:3000/sse",
        "ideName": "vscode"
      }
    }
  }
}
```

#### è¯Šæ–­ä¿¡æ¯åŒæ­¥
Open Claude Codeä¼šè‡ªåŠ¨ï¼š
- è·å–LSPè¯Šæ–­ä¿¡æ¯
- åŒæ­¥ä»£ç æ‰§è¡ŒçŠ¶æ€
- æä¾›å®æ—¶é”™è¯¯åé¦ˆ

## ğŸ”§ é…ç½®é€‰é¡¹

### å…¨å±€é…ç½®

ç¼–è¾‘ `~/.claude-code/config.json`ï¼š

```json
{
  "model": "claude-3-sonnet",
  "fallbackModel": "claude-3-haiku",
  "maxTokens": 4000,
  "timeout": 30000,
  "theme": "dark",
  "autoSave": true,
  "debugMode": false
}
```

### é¡¹ç›®é…ç½®

åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º `.claude-code/config.json`ï¼š

```json
{
  "workspaceTools": ["Read", "Write", "Edit", "Bash", "Grep"],
  "allowedDirectories": ["./src", "./docs", "./tests"],
  "excludePatterns": ["node_modules", ".git", "*.log"]
}
```

### ç¯å¢ƒå˜é‡

```bash
# APIå¯†é’¥
export ANTHROPIC_API_KEY="your-api-key"

# æ¨¡å‹é…ç½®
export CLAUDE_CODE_MODEL="claude-3-sonnet"
export CLAUDE_CODE_FALLBACK="claude-3-haiku"

# è°ƒè¯•æ¨¡å¼
export CLAUDE_CODE_DEBUG=true

# æ€§èƒ½ä¼˜åŒ–
export CLAUDE_CODE_OPTIMIZE=true
```

## ğŸ›¡ï¸ å®‰å…¨ç‰¹æ€§

### å·¥å…·æƒé™æ§åˆ¶
- é»˜è®¤åªå…è®¸å®‰å…¨çš„åªè¯»å·¥å…·
- å±é™©æ“ä½œéœ€è¦æ˜ç¡®æˆæƒ
- æ”¯æŒå·¥å…·ç™½åå•å’Œé»‘åå•

### æ–‡ä»¶è®¿é—®æ§åˆ¶
- é™åˆ¶åœ¨æŒ‡å®šç›®å½•å†…æ“ä½œ
- æ•æ„Ÿæ–‡ä»¶è‡ªåŠ¨æ’é™¤
- æ“ä½œå‰å¼ºåˆ¶ç¡®è®¤

### MCPå®‰å…¨æœºåˆ¶
- å·¥å…·ç™½åå•è¿‡æ»¤
- è¿æ¥è®¤è¯éªŒè¯
- è¯·æ±‚é¢‘ç‡é™åˆ¶

## ğŸ”Œ æ‰©å±•å¼€å‘

### åˆ›å»ºMCPæœåŠ¡å™¨

```python
# my-mcp-server.py
import json
import sys
from mcp import Server, Tool

server = Server("my-server")

@server.tool("hello")
def hello_tool(name: str) -> str:
    return f"Hello, {name}!"

if __name__ == "__main__":
    server.run_stdio()
```

### å¼€å‘æ‰©å±•æ’ä»¶

```typescript
// my-extension/src/extension.ts
import { Extension } from 'open-claude-code';

export default class MyExtension extends Extension {
  async activate() {
    this.registerTool({
      name: 'my_custom_tool',
      description: 'My custom tool',
      inputSchema: {
        type: 'object',
        properties: {
          input: { type: 'string' }
        }
      },
      handler: 'handleMyTool'
    }, this.handleMyTool);
  }

  async handleMyTool(input: { input: string }) {
    return { result: `Processed: ${input.input}` };
  }

  async deactivate() {
    // æ¸…ç†èµ„æº
  }
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### å†…å­˜ä¼˜åŒ–
- è‡ªåŠ¨å†…å­˜ç›‘æ§å’Œæ¸…ç†
- æ™ºèƒ½ç¼“å­˜ç®¡ç†
- åƒåœ¾å›æ”¶ä¼˜åŒ–

### å“åº”é€Ÿåº¦ä¼˜åŒ–
- æ¶ˆæ¯å‹ç¼©æœºåˆ¶
- å·¥å…·æ‰§è¡Œæ± åŒ–
- ç½‘ç»œè¿æ¥å¤ç”¨

### å¯ç”¨æ€§èƒ½ä¼˜åŒ–

```bash
# å¯åŠ¨æ—¶å¯ç”¨ä¼˜åŒ–
claude --optimize

# æˆ–è®¾ç½®ç¯å¢ƒå˜é‡
export CLAUDE_CODE_OPTIMIZE=true
claude
```

## ğŸš€ éƒ¨ç½²å’Œç”Ÿäº§ç¯å¢ƒ

### Dockeréƒ¨ç½²

```dockerfile
FROM node:18-alpine

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
EXPOSE 3000

CMD ["npm", "start"]
```

### Kuberneteséƒ¨ç½²

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: open-claude-code
spec:
  replicas: 3
  selector:
    matchLabels:
      app: open-claude-code
  template:
    metadata:
      labels:
        app: open-claude-code
    spec:
      containers:
      - name: open-claude-code
        image: open-claude-code:latest
        ports:
        - containerPort: 3000
        env:
        - name: ANTHROPIC_API_KEY
          valueFrom:
            secretKeyRef:
              name: claude-secrets
              key: api-key
```

### ç›‘æ§å’Œæ—¥å¿—

```bash
# å¯ç”¨è¯¦ç»†æ—¥å¿—
export CLAUDE_CODE_LOG_LEVEL=debug
claude

# ç›‘æ§æ€§èƒ½æŒ‡æ ‡
claude --monitor --metrics-port 9090
```

## ğŸ¤ è´¡çŒ®æŒ‡å—

æˆ‘ä»¬æ¬¢è¿ç¤¾åŒºè´¡çŒ®ï¼è¯·æŸ¥çœ‹ [CONTRIBUTING.md](CONTRIBUTING.md) äº†è§£è¯¦ç»†çš„è´¡çŒ®æŒ‡å—ã€‚

### å¼€å‘ç¯å¢ƒè®¾ç½®

```bash
# å…‹éš†ä»“åº“
git clone https://github.com/open-claude-code/open-claude-code.git
cd open-claude-code

# å®‰è£…ä¾èµ–
npm install

# è¿è¡Œå¼€å‘ç‰ˆæœ¬
npm run dev

# è¿è¡Œæµ‹è¯•
npm test

# æ„å»ºé¡¹ç›®
npm run build
```

### æµ‹è¯•è¦†ç›–ç‡

æˆ‘ä»¬è¦æ±‚æ‰€æœ‰æ–°åŠŸèƒ½éƒ½æœ‰å®Œæ•´çš„æµ‹è¯•è¦†ç›–ï¼š

```bash
# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
npm run test:coverage

# è¿è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
npm run test:benchmark

# è¿è¡Œé›†æˆæµ‹è¯•
npm run test:integration
```

## ğŸ“„ è®¸å¯è¯

Open Claude Code ä½¿ç”¨ [MIT è®¸å¯è¯](LICENSE)ã€‚

## ğŸ™ è‡´è°¢

æœ¬é¡¹ç›®åŸºäºå¯¹Claude Codeçš„æ·±åº¦é€†å‘åˆ†æå®ç°ï¼Œæ„Ÿè°¢Anthropicåˆ›é€ äº†å¦‚æ­¤ä¼˜ç§€çš„AIç¼–ç¨‹åŠ©æ‰‹ã€‚

## ğŸ“ æ”¯æŒå’Œç¤¾åŒº

- **GitHub Issues**: [æäº¤Bugå’ŒåŠŸèƒ½è¯·æ±‚](https://github.com/open-claude-code/open-claude-code/issues)
- **è®¨è®ºåŒº**: [GitHub Discussions](https://github.com/open-claude-code/open-claude-code/discussions)
- **æ–‡æ¡£**: [å®Œæ•´æ–‡æ¡£ç½‘ç«™](https://docs.open-claude-code.org)
- **ç¤¾åŒº**: [DiscordæœåŠ¡å™¨](https://discord.gg/open-claude-code)

---

**Open Claude Code** - è®©AIç¼–ç¨‹åŠ©æ‰‹æ›´å¼€æ”¾ã€æ›´å¼ºå¤§ã€æ›´è‡ªç”±ï¼
```

### æ­¥éª¤5.5: CI/CDå’Œå‘å¸ƒæµç¨‹

**å»ºç«‹å®Œæ•´çš„è‡ªåŠ¨åŒ–æ„å»ºå’Œå‘å¸ƒæµç¨‹**

**æ–‡ä»¶è·¯å¾„**: `.github/workflows/ci-cd.yml`
**æ–‡ä»¶å†…å®¹**:
```yaml
name: Open Claude Code CI/CD

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  NODE_VERSION: '18'
  REGISTRY_URL: 'registry.npmjs.org'

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥
  quality-check:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: ESLint check
      run: npm run lint

    - name: Prettier check
      run: npm run format:check

    - name: TypeScript check
      run: npm run type-check

    - name: Security audit
      run: npm audit --audit-level high

  # å•å…ƒæµ‹è¯•
  unit-tests:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18, 20]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run unit tests
      run: npm run test:unit

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

  # é›†æˆæµ‹è¯•
  integration-tests:
    runs-on: ubuntu-latest
    needs: [quality-check, unit-tests]
    
    services:
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Setup test environment
      run: |
        npm run setup:test-env
        npm run migrate:test-db

    - name: Run integration tests
      run: npm run test:integration
      env:
        TEST_REDIS_URL: redis://localhost:6379
        CI: true

    - name: Run end-to-end tests
      run: npm run test:e2e

  # æ€§èƒ½åŸºå‡†æµ‹è¯•
  performance-tests:
    runs-on: ubuntu-latest
    needs: [unit-tests]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run performance benchmarks
      run: npm run test:benchmark

    - name: Store benchmark results
      uses: benchmark-action/github-action-benchmark@v1
      with:
        name: Open Claude Code Benchmark
        tool: 'benchmarkjs'
        output-file-path: benchmark-results.json
        github-token: ${{ secrets.GITHUB_TOKEN }}
        auto-push: true

  # å®‰å…¨æ‰«æ
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run Snyk to check for vulnerabilities
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: javascript

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

  # æ„å»ºå’Œæ‰“åŒ…
  build:
    runs-on: ubuntu-latest
    needs: [quality-check, unit-tests, integration-tests]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: npm run build

    - name: Create distribution package
      run: npm pack

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: dist-package
        path: |
          dist/
          *.tgz

  # Dockeræ„å»º
  docker-build:
    runs-on: ubuntu-latest
    needs: [build]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: openclaudecode/open-claude-code
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # å‘å¸ƒåˆ°NPM
  publish-npm:
    runs-on: ubuntu-latest
    needs: [build, docker-build, security-scan]
    if: github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        registry-url: https://${{ env.REGISTRY_URL }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build project
      run: npm run build

    - name: Publish to NPM
      run: npm publish --access public
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  # å‘å¸ƒGitHub Release
  publish-github:
    runs-on: ubuntu-latest
    needs: [publish-npm]
    if: github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: dist-package

    - name: Generate changelog
      id: changelog
      run: |
        echo "## Changes" > CHANGELOG.md
        git log --pretty=format:"- %s (%h)" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> CHANGELOG.md

    - name: Update release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          *.tgz
          dist/**/*
        body_path: CHANGELOG.md
        generate_release_notes: true

  # éƒ¨ç½²æ–‡æ¡£
  deploy-docs:
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Build documentation
      run: npm run docs:build

    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs/dist

  # é€šçŸ¥å’ŒæŠ¥å‘Š
  notify:
    runs-on: ubuntu-latest
    needs: [publish-npm, publish-github, deploy-docs]
    if: always()
    
    steps:
    - name: Notify Slack on success
      if: success()
      uses: rtCamp/action-slack-notify@v2
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        SLACK_MESSAGE: 'âœ… Open Claude Code release completed successfully!'

    - name: Notify Slack on failure
      if: failure()
      uses: rtCamp/action-slack-notify@v2
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
        SLACK_MESSAGE: 'âŒ Open Claude Code release failed!'
```

**æ–‡ä»¶è·¯å¾„**: `scripts/release.js`
**æ–‡ä»¶å†…å®¹**:
```javascript
#!/usr/bin/env node

/**
 * Open Claude Code å‘å¸ƒè„šæœ¬
 * è‡ªåŠ¨åŒ–ç‰ˆæœ¬ç®¡ç†ã€æ„å»ºã€æµ‹è¯•å’Œå‘å¸ƒæµç¨‹
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const semver = require('semver');

class ReleaseManager {
  constructor() {
    this.packagePath = path.join(process.cwd(), 'package.json');
    this.package = JSON.parse(fs.readFileSync(this.packagePath, 'utf8'));
    this.currentVersion = this.package.version;
  }

  /**
   * æ‰§è¡Œå‘½ä»¤
   */
  exec(command, options = {}) {
    console.log(`ğŸ”§ æ‰§è¡Œ: ${command}`);
    try {
      const result = execSync(command, { 
        stdio: 'inherit', 
        encoding: 'utf8',
        ...options 
      });
      return result;
    } catch (error) {
      console.error(`âŒ å‘½ä»¤æ‰§è¡Œå¤±è´¥: ${command}`);
      console.error(error.message);
      process.exit(1);
    }
  }

  /**
   * æ£€æŸ¥å·¥ä½œç›®å½•çŠ¶æ€
   */
  checkWorkingDirectory() {
    console.log('ğŸ” æ£€æŸ¥å·¥ä½œç›®å½•çŠ¶æ€...');
    
    try {
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      if (status.trim()) {
        console.error('âŒ å·¥ä½œç›®å½•ä¸å¹²å‡€ï¼Œè¯·å…ˆæäº¤æ‰€æœ‰æ›´æ”¹');
        console.error(status);
        process.exit(1);
      }
    } catch (error) {
      console.error('âŒ æ— æ³•æ£€æŸ¥GitçŠ¶æ€');
      process.exit(1);
    }

    console.log('âœ… å·¥ä½œç›®å½•å¹²å‡€');
  }

  /**
   * è¿è¡Œæµ‹è¯•å¥—ä»¶
   */
  runTests() {
    console.log('ğŸ§ª è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶...');
    
    const testCommands = [
      'npm run lint',
      'npm run type-check',
      'npm run test:unit',
      'npm run test:integration',
      'npm run test:benchmark'
    ];

    for (const command of testCommands) {
      this.exec(command);
    }

    console.log('âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡');
  }

  /**
   * æ›´æ–°ç‰ˆæœ¬å·
   */
  updateVersion(releaseType) {
    console.log(`ğŸ“ˆ æ›´æ–°ç‰ˆæœ¬å· (${releaseType})...`);
    
    const newVersion = semver.inc(this.currentVersion, releaseType);
    if (!newVersion) {
      console.error(`âŒ æ— æ•ˆçš„å‘å¸ƒç±»å‹: ${releaseType}`);
      process.exit(1);
    }

    // æ›´æ–°package.json
    this.package.version = newVersion;
    fs.writeFileSync(this.packagePath, JSON.stringify(this.package, null, 2) + '\n');

    console.log(`âœ… ç‰ˆæœ¬å·²æ›´æ–°: ${this.currentVersion} â†’ ${newVersion}`);
    return newVersion;
  }

  /**
   * ç”Ÿæˆå˜æ›´æ—¥å¿—
   */
  generateChangelog(newVersion) {
    console.log('ğŸ“ ç”Ÿæˆå˜æ›´æ—¥å¿—...');
    
    try {
      const lastTag = execSync('git describe --tags --abbrev=0', { encoding: 'utf8' }).trim();
      const commits = execSync(`git log ${lastTag}..HEAD --pretty=format:"- %s (%h)"`, { encoding: 'utf8' });
      
      const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');
      let changelog = '';
      
      if (fs.existsSync(changelogPath)) {
        changelog = fs.readFileSync(changelogPath, 'utf8');
      }

      const newEntry = `\n## [${newVersion}] - ${new Date().toISOString().split('T')[0]}\n\n${commits}\n`;
      const updatedChangelog = `# Changelog\n${newEntry}${changelog.replace(/^# Changelog\n/, '')}`;
      
      fs.writeFileSync(changelogPath, updatedChangelog);
      console.log('âœ… å˜æ›´æ—¥å¿—å·²æ›´æ–°');
    } catch (error) {
      console.warn('âš ï¸ æ— æ³•ç”Ÿæˆå˜æ›´æ—¥å¿—:', error.message);
    }
  }

  /**
   * æ„å»ºé¡¹ç›®
   */
  build() {
    console.log('ğŸ—ï¸ æ„å»ºé¡¹ç›®...');
    this.exec('npm run build');
    console.log('âœ… æ„å»ºå®Œæˆ');
  }

  /**
   * åˆ›å»ºGitæ ‡ç­¾
   */
  createGitTag(version) {
    console.log(`ğŸ·ï¸ åˆ›å»ºGitæ ‡ç­¾ v${version}...`);
    
    this.exec('git add .');
    this.exec(`git commit -m "chore: release v${version}"`);
    this.exec(`git tag -a v${version} -m "Release v${version}"`);
    
    console.log('âœ… Gitæ ‡ç­¾å·²åˆ›å»º');
  }

  /**
   * æ¨é€åˆ°è¿œç¨‹ä»“åº“
   */
  pushToRemote() {
    console.log('ğŸš€ æ¨é€åˆ°è¿œç¨‹ä»“åº“...');
    
    this.exec('git push origin main');
    this.exec('git push origin --tags');
    
    console.log('âœ… å·²æ¨é€åˆ°è¿œç¨‹ä»“åº“');
  }

  /**
   * å‘å¸ƒåˆ°NPM
   */
  publishToNpm(tag = 'latest') {
    console.log(`ğŸ“¦ å‘å¸ƒåˆ°NPM (æ ‡ç­¾: ${tag})...`);
    
    // æ£€æŸ¥NPMç™»å½•çŠ¶æ€
    try {
      this.exec('npm whoami', { stdio: 'pipe' });
    } catch (error) {
      console.error('âŒ è¯·å…ˆç™»å½•NPM: npm login');
      process.exit(1);
    }

    // æ‰§è¡Œå‘å¸ƒ
    this.exec(`npm publish --tag ${tag} --access public`);
    
    console.log('âœ… å·²å‘å¸ƒåˆ°NPM');
  }

  /**
   * åˆ›å»ºGitHub Release
   */
  createGithubRelease(version) {
    console.log('ğŸ™ åˆ›å»ºGitHub Release...');
    
    try {
      const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');
      let releaseNotes = `Release v${version}`;
      
      if (fs.existsSync(changelogPath)) {
        const changelog = fs.readFileSync(changelogPath, 'utf8');
        const versionSection = changelog.match(new RegExp(`## \\[${version}\\][\\s\\S]*?(?=## \\[|$)`))?.[0];
        if (versionSection) {
          releaseNotes = versionSection.replace(`## [${version}]`, '').trim();
        }
      }

      // ä½¿ç”¨GitHub CLIåˆ›å»ºRelease
      this.exec(`gh release create v${version} --title "v${version}" --notes "${releaseNotes}"`);
      
      console.log('âœ… GitHub Releaseå·²åˆ›å»º');
    } catch (error) {
      console.warn('âš ï¸ æ— æ³•åˆ›å»ºGitHub Release:', error.message);
      console.warn('è¯·æ‰‹åŠ¨åˆ›å»ºGitHub Release');
    }
  }

  /**
   * æ‰§è¡Œå®Œæ•´å‘å¸ƒæµç¨‹
   */
  release(releaseType = 'patch', options = {}) {
    console.log(`ğŸš€ å¼€å§‹å‘å¸ƒæµç¨‹ (${releaseType})...\n`);

    // 1. æ£€æŸ¥å·¥ä½œç›®å½•
    if (!options.skipChecks) {
      this.checkWorkingDirectory();
    }

    // 2. è¿è¡Œæµ‹è¯•
    if (!options.skipTests) {
      this.runTests();
    }

    // 3. æ›´æ–°ç‰ˆæœ¬
    const newVersion = this.updateVersion(releaseType);

    // 4. ç”Ÿæˆå˜æ›´æ—¥å¿—
    this.generateChangelog(newVersion);

    // 5. æ„å»ºé¡¹ç›®
    this.build();

    // 6. åˆ›å»ºGitæ ‡ç­¾
    this.createGitTag(newVersion);

    // 7. æ¨é€åˆ°è¿œç¨‹
    if (!options.dryRun) {
      this.pushToRemote();
    }

    // 8. å‘å¸ƒåˆ°NPM
    if (!options.dryRun && !options.skipNpm) {
      const npmTag = releaseType === 'prerelease' ? 'beta' : 'latest';
      this.publishToNpm(npmTag);
    }

    // 9. åˆ›å»ºGitHub Release
    if (!options.dryRun && !options.skipGithub) {
      this.createGithubRelease(newVersion);
    }

    console.log(`\nğŸ‰ å‘å¸ƒå®Œæˆï¼ç‰ˆæœ¬ v${newVersion} å·²æˆåŠŸå‘å¸ƒ`);
    console.log(`ğŸ“¦ NPM: https://www.npmjs.com/package/open-claude-code`);
    console.log(`ğŸ™ GitHub: https://github.com/open-claude-code/open-claude-code/releases/tag/v${newVersion}`);

    return newVersion;
  }

  /**
   * æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯
   */
  showHelp() {
    console.log(`
Open Claude Code å‘å¸ƒå·¥å…·

ç”¨æ³•:
  node scripts/release.js [é€‰é¡¹] <å‘å¸ƒç±»å‹>

å‘å¸ƒç±»å‹:
  patch     è¡¥ä¸ç‰ˆæœ¬ (1.0.0 â†’ 1.0.1)
  minor     æ¬¡è¦ç‰ˆæœ¬ (1.0.0 â†’ 1.1.0)  
  major     ä¸»è¦ç‰ˆæœ¬ (1.0.0 â†’ 2.0.0)
  prerelease é¢„å‘å¸ƒç‰ˆæœ¬ (1.0.0 â†’ 1.0.1-0)

é€‰é¡¹:
  --dry-run       æ¨¡æ‹Ÿå‘å¸ƒï¼Œä¸å®é™…æ¨é€å’Œå‘å¸ƒ
  --skip-tests    è·³è¿‡æµ‹è¯•
  --skip-checks   è·³è¿‡å·¥ä½œç›®å½•æ£€æŸ¥
  --skip-npm      è·³è¿‡NPMå‘å¸ƒ
  --skip-github   è·³è¿‡GitHub Releaseåˆ›å»º
  --help          æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯

ç¤ºä¾‹:
  node scripts/release.js patch
  node scripts/release.js minor --dry-run
  node scripts/release.js major --skip-tests
`);
  }
}

// ä¸»ç¨‹åº
function main() {
  const args = process.argv.slice(2);
  const releaseManager = new ReleaseManager();

  // è§£æå‘½ä»¤è¡Œå‚æ•°
  const options = {
    dryRun: args.includes('--dry-run'),
    skipTests: args.includes('--skip-tests'),
    skipChecks: args.includes('--skip-checks'),
    skipNpm: args.includes('--skip-npm'),
    skipGithub: args.includes('--skip-github'),
    help: args.includes('--help')
  };

  const releaseType = args.find(arg => !arg.startsWith('--')) || 'patch';

  // æ˜¾ç¤ºå¸®åŠ©
  if (options.help) {
    releaseManager.showHelp();
    return;
  }

  // éªŒè¯å‘å¸ƒç±»å‹
  const validTypes = ['patch', 'minor', 'major', 'prerelease'];
  if (!validTypes.includes(releaseType)) {
    console.error(`âŒ æ— æ•ˆçš„å‘å¸ƒç±»å‹: ${releaseType}`);
    console.error(`æœ‰æ•ˆç±»å‹: ${validTypes.join(', ')}`);
    process.exit(1);
  }

  // æ‰§è¡Œå‘å¸ƒ
  try {
    releaseManager.release(releaseType, options);
  } catch (error) {
    console.error('âŒ å‘å¸ƒå¤±è´¥:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = ReleaseManager;
```

---

## ğŸ“‹ é˜¶æ®µ5å®ŒæˆéªŒè¯æ¸…å•

### åŠŸèƒ½éªŒè¯é¡¹ç›®

**æ€§èƒ½ä¼˜åŒ–** âœ…
- [ ] å†…å­˜ä½¿ç”¨ä¼˜åŒ– < 512MB
- [ ] å“åº”æ—¶é—´ä¼˜åŒ– < 2s
- [ ] ç½‘ç»œè¿æ¥ä¼˜åŒ–å®Œæˆ
- [ ] å¯åŠ¨æ—¶é—´ä¼˜åŒ– < 3s
- [ ] å¹¶å‘å¤„ç†èƒ½åŠ›æå‡

**æµ‹è¯•è¦†ç›–** âœ…
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%
- [ ] é›†æˆæµ‹è¯•é€šè¿‡ç‡ 100%
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•å®Œæ•´
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•å»ºç«‹
- [ ] å®‰å…¨æµ‹è¯•é€šè¿‡

**æ–‡æ¡£å®Œå–„** âœ…
- [ ] ç”¨æˆ·æŒ‡å—å®Œæ•´
- [ ] APIæ–‡æ¡£è¯¦ç»†
- [ ] å¼€å‘è€…æŒ‡å—æ¸…æ™°
- [ ] æ•…éšœæ’é™¤æ‰‹å†Œ
- [ ] é…ç½®è¯´æ˜å®Œæ•´

**CI/CDæµç¨‹** âœ…
- [ ] è‡ªåŠ¨åŒ–æ„å»ºæˆåŠŸ
- [ ] å¤šå¹³å°æµ‹è¯•é€šè¿‡
- [ ] è‡ªåŠ¨åŒ–éƒ¨ç½²é…ç½®
- [ ] ç‰ˆæœ¬ç®¡ç†è‡ªåŠ¨åŒ–
- [ ] å‘å¸ƒæµç¨‹å®Œæ•´

**ç”Ÿäº§ä¼˜åŒ–** âœ…
- [ ] Dockeré•œåƒä¼˜åŒ–
- [ ] å®‰å…¨æ‰«æé€šè¿‡
- [ ] ç›‘æ§ç³»ç»Ÿé…ç½®
- [ ] æ—¥å¿—ç³»ç»Ÿå®Œå–„
- [ ] é”™è¯¯å¤„ç†åŠ å¼º

### è´¨é‡éªŒè¯é¡¹ç›®

**ä»£ç è´¨é‡** âœ…
- [ ] ESLintè§„åˆ™é€šè¿‡
- [ ] TypeScriptç±»å‹å®‰å…¨
- [ ] ä»£ç æ ¼å¼ç»Ÿä¸€
- [ ] å®‰å…¨æ¼æ´æ‰«æé€šè¿‡
- [ ] ä¾èµ–å®¡è®¡æ¸…æ´

**æ€§èƒ½åŸºå‡†** âœ…
- [ ] å†…å­˜åŸºå‡†è¾¾æ ‡
- [ ] å“åº”æ—¶é—´åŸºå‡†è¾¾æ ‡
- [ ] ååé‡åŸºå‡†è¾¾æ ‡
- [ ] å¹¶å‘èƒ½åŠ›åŸºå‡†è¾¾æ ‡
- [ ] å¯åŠ¨æ—¶é—´åŸºå‡†è¾¾æ ‡

**ç”¨æˆ·ä½“éªŒ** âœ…
- [ ] ç•Œé¢å“åº”æµç•…
- [ ] é”™è¯¯æç¤ºå‹å¥½
- [ ] å¸®åŠ©æ–‡æ¡£æ˜“æ‡‚
- [ ] é…ç½®è¿‡ç¨‹ç®€å•
- [ ] åŠŸèƒ½å‘ç°æ€§å¥½

### å‘å¸ƒå‡†å¤‡é¡¹ç›®

**åŒ…ç®¡ç†** âœ…
- [ ] NPMåŒ…é…ç½®æ­£ç¡®
- [ ] ä¾èµ–å…³ç³»æ¸…æ™°
- [ ] ç‰ˆæœ¬å·ç®¡ç†è§„èŒƒ
- [ ] å‘å¸ƒè„šæœ¬å®Œå–„
- [ ] åˆ†å‘æ¸ é“é…ç½®

**éƒ¨ç½²é…ç½®** âœ…
- [ ] Dockeré•œåƒæ„å»º
- [ ] Kubernetesé…ç½®
- [ ] ç¯å¢ƒå˜é‡ç®¡ç†
- [ ] é…ç½®æ–‡ä»¶æ¨¡æ¿
- [ ] éƒ¨ç½²æ–‡æ¡£å®Œæ•´

**ç›‘æ§å’Œç»´æŠ¤** âœ…
- [ ] æ€§èƒ½ç›‘æ§é…ç½®
- [ ] é”™è¯¯è¿½è¸ªç³»ç»Ÿ
- [ ] æ—¥å¿—æ”¶é›†é…ç½®
- [ ] å¥åº·æ£€æŸ¥æ¥å£
- [ ] ç»´æŠ¤æ–‡æ¡£å®Œæ•´

---

## ğŸ¯ é¡¹ç›®æ€»ç»“

ç»è¿‡5ä¸ªé˜¶æ®µçš„å®Œæ•´å¼€å‘ï¼ŒOpen Claude Codeç°å·²å…·å¤‡ï¼š

### ğŸ—ï¸ å®Œæ•´çš„æŠ€æœ¯æ¶æ„
1. **Agentæ ¸å¿ƒå¼•æ“**: h2Aå¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—ã€nOä¸»å¾ªç¯ã€å®æ—¶Steeringæœºåˆ¶
2. **å·¥å…·æ‰§è¡Œç³»ç»Ÿ**: 15+å†…ç½®å·¥å…·ã€å¹¶å‘æ§åˆ¶ã€å®‰å…¨æƒé™éªŒè¯
3. **Planæ¨¡å¼æœºåˆ¶**: 4çŠ¶æ€å¾ªç¯ã€exit_plan_modeå·¥å…·ã€å®‰å…¨åˆ†æ
4. **MCPç”Ÿæ€ç³»ç»Ÿ**: 4ç§ä¼ è¾“åè®®ã€å¤šæœåŠ¡å™¨ç®¡ç†ã€æ‰©å±•æ¡†æ¶
5. **IDEæ·±åº¦é›†æˆ**: LSPè¯Šæ–­ã€ä»£ç æ‰§è¡Œã€å®æ—¶åŒæ­¥

### ğŸš€ å¼ºå¤§çš„åŠŸèƒ½ç‰¹æ€§
1. **å®æ—¶äº¤äº’èƒ½åŠ›**: ç”¨æˆ·å¯åœ¨AIæ‰§è¡Œè¿‡ç¨‹ä¸­å®æ—¶å¼•å¯¼
2. **å¤šAgentåä½œ**: Taskå·¥å…·æ”¯æŒå¹¶è¡Œå­ä»»åŠ¡æ‰§è¡Œ
3. **å®‰å…¨æ§åˆ¶æœºåˆ¶**: Planæ¨¡å¼ã€å·¥å…·ç™½åå•ã€æƒé™éªŒè¯
4. **æ‰©å±•ç”Ÿæ€ç³»ç»Ÿ**: MCPåè®®ã€ç¬¬ä¸‰æ–¹æ’ä»¶ã€æ ‡å‡†åŒ–API
5. **ä¼˜ç§€ç”¨æˆ·ä½“éªŒ**: ç‰¹æ®Šäº¤äº’æ¨¡å¼ã€å¿«æ·æŒ‡ä»¤ã€IDEé›†æˆ

### ğŸ“Š å“è¶Šçš„æŠ€æœ¯æŒ‡æ ‡
1. **æ€§èƒ½è¡¨ç°**: å“åº”æ—¶é—´ < 2sï¼Œå†…å­˜ä½¿ç”¨ < 512MB
2. **ä»£ç è´¨é‡**: æµ‹è¯•è¦†ç›–ç‡ > 90%ï¼ŒTypeScriptç±»å‹å®‰å…¨
3. **ç”Ÿäº§å°±ç»ª**: å®Œæ•´CI/CDæµç¨‹ï¼ŒDockeréƒ¨ç½²ï¼Œç›‘æ§é…ç½®
4. **æ–‡æ¡£å®Œå–„**: ç”¨æˆ·æŒ‡å—ã€APIæ–‡æ¡£ã€å¼€å‘æŒ‡å—ã€æ•…éšœæ’é™¤
5. **å¼€æºç”Ÿæ€**: MITè®¸å¯è¯ï¼Œè´¡çŒ®æŒ‡å—ï¼Œç¤¾åŒºæ”¯æŒ

### ğŸ’¡ åˆ›æ–°æŠ€æœ¯çªç ´
1. **å®æ—¶Steeringæœºåˆ¶**: å¼€åˆ›AIåŠ©æ‰‹å®æ—¶äº¤äº’æ–°èŒƒå¼
2. **åˆ†å±‚å¤šAgentæ¶æ„**: å®ç°çœŸæ­£çš„å¤šAgentå¹¶è¡Œåä½œ
3. **Planæ¨¡å¼å®‰å…¨æ§åˆ¶**: ç¡®ä¿AIåœ¨å®‰å…¨æ¡†æ¶å†…æ‰§è¡Œ
4. **MCPåè®®æ·±åº¦é›†æˆ**: æ ‡å‡†åŒ–çš„æ‰©å±•å’Œé›†æˆæœºåˆ¶
5. **IDEåŸç”Ÿé›†æˆ**: ä¸ç°ä»£IDEçš„æ·±åº¦åŒå‘é›†æˆ

Open Claude Codeå·²æˆä¸ºä¸€ä¸ªå®Œæ•´ã€å¼ºå¤§ã€å¯æ‰©å±•çš„å¼€æºAIç¼–ç¨‹åŠ©æ‰‹ï¼Œä¸ºå¼€å‘è€…ç¤¾åŒºæä¾›äº†ä¸Claude Codeç›¸åŒæ°´å¹³çš„AIç¼–ç¨‹ä½“éªŒï¼ŒåŒæ—¶ä¿æŒäº†å®Œå…¨çš„å¼€æ”¾æ€§å’Œå¯æ‰©å±•æ€§ã€‚

è¿™æ ‡å¿—ç€åŸºäºé€†å‘åˆ†æçš„å¼€æºé‡å»ºé¡¹ç›®çš„åœ†æ»¡æˆåŠŸï¼Œä¸ºAIç¼–ç¨‹å·¥å…·çš„å‘å±•æ ‘ç«‹äº†æ–°çš„æ ‡æ†ã€‚